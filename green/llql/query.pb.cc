// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: query.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "query.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace llql_proto {

namespace {

const ::google::protobuf::Descriptor* Distinct_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Distinct_reflection_ = NULL;
const ::google::protobuf::Descriptor* Exchange_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Exchange_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Exchange_ExchangeType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ExtScan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExtScan_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ExtScan_DSType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Filter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Filter_reflection_ = NULL;
const ::google::protobuf::Descriptor* Generator_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Generator_reflection_ = NULL;
const ::google::protobuf::Descriptor* HashAgg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HashAgg_reflection_ = NULL;
const ::google::protobuf::Descriptor* HashJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HashJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* Limit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Limit_reflection_ = NULL;
const ::google::protobuf::Descriptor* NestedLoopJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NestedLoopJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* Project_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Project_reflection_ = NULL;
const ::google::protobuf::Descriptor* Sample_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sample_reflection_ = NULL;
const ::google::protobuf::Descriptor* SetOp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SetOp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SetOp_SetOpType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Sort_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sort_reflection_ = NULL;
const ::google::protobuf::Descriptor* SortLimit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SortLimit_reflection_ = NULL;
const ::google::protobuf::Descriptor* Emit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Emit_reflection_ = NULL;
const ::google::protobuf::Descriptor* Relation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Relation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Query_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Query_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* JoinType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_query_2eproto() {
  protobuf_AddDesc_query_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "query.proto");
  GOOGLE_CHECK(file != NULL);
  Distinct_descriptor_ = file->message_type(0);
  static const int Distinct_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Distinct, is_partial_),
  };
  Distinct_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Distinct_descriptor_,
      Distinct::default_instance_,
      Distinct_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Distinct, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Distinct, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Distinct));
  Exchange_descriptor_ = file->message_type(1);
  static const int Exchange_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exchange, x_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exchange, x_part_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exchange, x_exprs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exchange, x_sortexprs_),
  };
  Exchange_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Exchange_descriptor_,
      Exchange::default_instance_,
      Exchange_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exchange, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exchange, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Exchange));
  Exchange_ExchangeType_descriptor_ = Exchange_descriptor_->enum_type(0);
  ExtScan_descriptor_ = file->message_type(2);
  static const int ExtScan_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtScan, ds_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtScan, urls_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtScan, cols_),
  };
  ExtScan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExtScan_descriptor_,
      ExtScan::default_instance_,
      ExtScan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtScan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtScan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExtScan));
  ExtScan_DSType_descriptor_ = ExtScan_descriptor_->enum_type(0);
  Filter_descriptor_ = file->message_type(3);
  static const int Filter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filter, predicate_),
  };
  Filter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Filter_descriptor_,
      Filter::default_instance_,
      Filter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Filter));
  Generator_descriptor_ = file->message_type(4);
  static const int Generator_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Generator, expand_array_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Generator, gen_function_),
  };
  Generator_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Generator_descriptor_,
      Generator::default_instance_,
      Generator_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Generator, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Generator, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Generator));
  HashAgg_descriptor_ = file->message_type(5);
  static const int HashAgg_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashAgg, is_partial_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashAgg, is_top_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashAgg, grp_exprs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashAgg, proj_exprs_),
  };
  HashAgg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HashAgg_descriptor_,
      HashAgg::default_instance_,
      HashAgg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashAgg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashAgg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HashAgg));
  HashJoin_descriptor_ = file->message_type(6);
  static const int HashJoin_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashJoin, left_keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashJoin, right_keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashJoin, build_side_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashJoin, join_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashJoin, extra_predicate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashJoin, broadcast_),
  };
  HashJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HashJoin_descriptor_,
      HashJoin::default_instance_,
      HashJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HashJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HashJoin));
  Limit_descriptor_ = file->message_type(7);
  static const int Limit_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, offset_),
  };
  Limit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Limit_descriptor_,
      Limit::default_instance_,
      Limit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Limit));
  NestedLoopJoin_descriptor_ = file->message_type(8);
  static const int NestedLoopJoin_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NestedLoopJoin, build_side_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NestedLoopJoin, join_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NestedLoopJoin, predicate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NestedLoopJoin, broadcast_),
  };
  NestedLoopJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NestedLoopJoin_descriptor_,
      NestedLoopJoin::default_instance_,
      NestedLoopJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NestedLoopJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NestedLoopJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NestedLoopJoin));
  Project_descriptor_ = file->message_type(9);
  static const int Project_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, exprs_),
  };
  Project_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Project_descriptor_,
      Project::default_instance_,
      Project_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Project));
  Sample_descriptor_ = file->message_type(10);
  static const int Sample_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sample, fraction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sample, with_replacement_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sample, seed_),
  };
  Sample_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Sample_descriptor_,
      Sample::default_instance_,
      Sample_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sample, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sample, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Sample));
  SetOp_descriptor_ = file->message_type(11);
  static const int SetOp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetOp, setop_type_),
  };
  SetOp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SetOp_descriptor_,
      SetOp::default_instance_,
      SetOp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetOp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetOp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SetOp));
  SetOp_SetOpType_descriptor_ = SetOp_descriptor_->enum_type(0);
  Sort_descriptor_ = file->message_type(12);
  static const int Sort_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sort, sort_exprs_),
  };
  Sort_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Sort_descriptor_,
      Sort::default_instance_,
      Sort_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sort, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sort, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Sort));
  SortLimit_descriptor_ = file->message_type(13);
  static const int SortLimit_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SortLimit, sort_exprs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SortLimit, limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SortLimit, offset_),
  };
  SortLimit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SortLimit_descriptor_,
      SortLimit::default_instance_,
      SortLimit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SortLimit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SortLimit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SortLimit));
  Emit_descriptor_ = file->message_type(14);
  static const int Emit_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Emit, limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Emit, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Emit, sample_rate_),
  };
  Emit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Emit_descriptor_,
      Emit::default_instance_,
      Emit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Emit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Emit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Emit));
  Relation_descriptor_ = file->message_type(15);
  static const int Relation_offsets_[19] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, rel_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, rel_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, schema_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, children_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, distinct_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, exchange_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, extscan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, filter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, generator_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, hashagg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, hashjoin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, nestedloopjoin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, project_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, sample_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, setop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, sort_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, sortlimit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, emit_),
  };
  Relation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Relation_descriptor_,
      Relation::default_instance_,
      Relation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Relation));
  Query_descriptor_ = file->message_type(16);
  static const int Query_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, root_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, rels_),
  };
  Query_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Query_descriptor_,
      Query::default_instance_,
      Query_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Query));
  JoinType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_query_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Distinct_descriptor_, &Distinct::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Exchange_descriptor_, &Exchange::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExtScan_descriptor_, &ExtScan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Filter_descriptor_, &Filter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Generator_descriptor_, &Generator::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HashAgg_descriptor_, &HashAgg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HashJoin_descriptor_, &HashJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Limit_descriptor_, &Limit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NestedLoopJoin_descriptor_, &NestedLoopJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Project_descriptor_, &Project::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Sample_descriptor_, &Sample::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SetOp_descriptor_, &SetOp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Sort_descriptor_, &Sort::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SortLimit_descriptor_, &SortLimit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Emit_descriptor_, &Emit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Relation_descriptor_, &Relation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Query_descriptor_, &Query::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_query_2eproto() {
  delete Distinct::default_instance_;
  delete Distinct_reflection_;
  delete Exchange::default_instance_;
  delete Exchange_reflection_;
  delete ExtScan::default_instance_;
  delete ExtScan_reflection_;
  delete Filter::default_instance_;
  delete Filter_reflection_;
  delete Generator::default_instance_;
  delete Generator_reflection_;
  delete HashAgg::default_instance_;
  delete HashAgg_reflection_;
  delete HashJoin::default_instance_;
  delete HashJoin_reflection_;
  delete Limit::default_instance_;
  delete Limit_reflection_;
  delete NestedLoopJoin::default_instance_;
  delete NestedLoopJoin_reflection_;
  delete Project::default_instance_;
  delete Project_reflection_;
  delete Sample::default_instance_;
  delete Sample_reflection_;
  delete SetOp::default_instance_;
  delete SetOp_reflection_;
  delete Sort::default_instance_;
  delete Sort_reflection_;
  delete SortLimit::default_instance_;
  delete SortLimit_reflection_;
  delete Emit::default_instance_;
  delete Emit_reflection_;
  delete Relation::default_instance_;
  delete Relation_reflection_;
  delete Query::default_instance_;
  delete Query_reflection_;
}

void protobuf_AddDesc_query_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::llql_proto::protobuf_AddDesc_data_2eproto();
  ::llql_proto::protobuf_AddDesc_expr_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013query.proto\022\nllql_proto\032\ndata.proto\032\ne"
    "xpr.proto\"\036\n\010Distinct\022\022\n\nis_partial\030\001 \002("
    "\010\"\317\001\n\010Exchange\0221\n\006x_type\030\001 \002(\0162!.llql_pr"
    "oto.Exchange.ExchangeType\022\016\n\006x_part\030\002 \002("
    "\005\022!\n\007x_exprs\030\003 \003(\0132\020.llql_proto.Expr\022)\n\013"
    "x_sortexprs\030\004 \003(\0132\024.llql_proto.SortExpr\""
    "2\n\014ExchangeType\022\r\n\tBROADCAST\020\000\022\010\n\004HASH\020\001"
    "\022\t\n\005RANGE\020\002\"\223\001\n\007ExtScan\022+\n\007ds_type\030\001 \002(\016"
    "2\032.llql_proto.ExtScan.DSType\022\014\n\004urls\030\002 \003"
    "(\t\022 \n\004cols\030\003 \002(\0132\022.llql_proto.Schema\"+\n\006"
    "DSType\022\007\n\003CSV\020\000\022\013\n\007PG_TEXT\020\001\022\013\n\007PARQUET\020"
    "\002\"-\n\006Filter\022#\n\tpredicate\030\001 \002(\0132\020.llql_pr"
    "oto.Expr\"[\n\tGenerator\022&\n\014expand_array\030\001 "
    "\003(\0132\020.llql_proto.Expr\022&\n\014gen_function\030\002 "
    "\001(\0132\020.llql_proto.Expr\"x\n\007HashAgg\022\022\n\nis_p"
    "artial\030\001 \002(\010\022\016\n\006is_top\030\002 \002(\010\022#\n\tgrp_expr"
    "s\030\003 \003(\0132\020.llql_proto.Expr\022$\n\nproj_exprs\030"
    "\004 \003(\0132\020.llql_proto.Expr\"\320\001\n\010HashJoin\022#\n\t"
    "left_keys\030\001 \003(\0132\020.llql_proto.Expr\022$\n\nrig"
    "ht_keys\030\002 \003(\0132\020.llql_proto.Expr\022\022\n\nbuild"
    "_side\030\003 \002(\005\022\'\n\tjoin_type\030\004 \002(\0162\024.llql_pr"
    "oto.JoinType\022)\n\017extra_predicate\030\005 \001(\0132\020."
    "llql_proto.Expr\022\021\n\tbroadcast\030\006 \002(\010\"&\n\005Li"
    "mit\022\r\n\005limit\030\001 \002(\003\022\016\n\006offset\030\002 \002(\003\"\205\001\n\016N"
    "estedLoopJoin\022\022\n\nbuild_side\030\001 \002(\005\022\'\n\tjoi"
    "n_type\030\002 \002(\0162\024.llql_proto.JoinType\022#\n\tpr"
    "edicate\030\003 \001(\0132\020.llql_proto.Expr\022\021\n\tbroad"
    "cast\030\004 \002(\010\"*\n\007Project\022\037\n\005exprs\030\001 \003(\0132\020.l"
    "lql_proto.Expr\"B\n\006Sample\022\020\n\010fraction\030\001 \002"
    "(\001\022\030\n\020with_replacement\030\002 \002(\010\022\014\n\004seed\030\003 \002"
    "(\003\"z\n\005SetOp\022/\n\nsetop_type\030\001 \002(\0162\033.llql_p"
    "roto.SetOp.SetOpType\"@\n\tSetOpType\022\t\n\005UNI"
    "ON\020\000\022\r\n\tUNION_ALL\020\001\022\r\n\tINTERSECT\020\002\022\n\n\006EX"
    "CEPT\020\003\"0\n\004Sort\022(\n\nsort_exprs\030\001 \003(\0132\024.llq"
    "l_proto.SortExpr\"T\n\tSortLimit\022(\n\nsort_ex"
    "prs\030\001 \003(\0132\024.llql_proto.SortExpr\022\r\n\005limit"
    "\030\002 \002(\003\022\016\n\006offset\030\003 \002(\003\":\n\004Emit\022\r\n\005limit\030"
    "\001 \002(\003\022\016\n\006offset\030\002 \002(\003\022\023\n\013sample_rate\030\003 \002"
    "(\003\"\240\005\n\010Relation\022\016\n\006rel_id\030\001 \002(\005\022\020\n\010rel_n"
    "ame\030\002 \001(\t\022\"\n\006schema\030\003 \002(\0132\022.llql_proto.S"
    "chema\022\020\n\010children\030\004 \003(\005\022&\n\010distinct\030\005 \001("
    "\0132\024.llql_proto.Distinct\022&\n\010exchange\030\006 \001("
    "\0132\024.llql_proto.Exchange\022$\n\007extscan\030\007 \001(\013"
    "2\023.llql_proto.ExtScan\022\"\n\006filter\030\010 \001(\0132\022."
    "llql_proto.Filter\022(\n\tgenerator\030\t \001(\0132\025.l"
    "lql_proto.Generator\022$\n\007hashagg\030\n \001(\0132\023.l"
    "lql_proto.HashAgg\022&\n\010hashjoin\030\013 \001(\0132\024.ll"
    "ql_proto.HashJoin\022 \n\005limit\030\014 \001(\0132\021.llql_"
    "proto.Limit\0222\n\016nestedloopjoin\030\r \001(\0132\032.ll"
    "ql_proto.NestedLoopJoin\022$\n\007project\030\016 \001(\013"
    "2\023.llql_proto.Project\022\"\n\006sample\030\017 \001(\0132\022."
    "llql_proto.Sample\022 \n\005setop\030\020 \001(\0132\021.llql_"
    "proto.SetOp\022\036\n\004sort\030\021 \001(\0132\020.llql_proto.S"
    "ort\022(\n\tsortlimit\030\022 \001(\0132\025.llql_proto.Sort"
    "Limit\022\036\n\004emit\030\023 \001(\0132\020.llql_proto.Emit\"9\n"
    "\005Query\022\014\n\004root\030\001 \002(\005\022\"\n\004rels\030\002 \003(\0132\024.llq"
    "l_proto.Relation*U\n\010JoinType\022\t\n\005INNER\020\000\022"
    "\016\n\nLEFT_OUTER\020\001\022\017\n\013RIGHT_OUTER\020\002\022\016\n\nFULL"
    "_OUTER\020\003\022\r\n\tLEFT_SEMI\020\004B,\n\037com.vitesseda"
    "ta.llql.llql_protoB\tLLQLQuery", 2389);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "query.proto", &protobuf_RegisterTypes);
  Distinct::default_instance_ = new Distinct();
  Exchange::default_instance_ = new Exchange();
  ExtScan::default_instance_ = new ExtScan();
  Filter::default_instance_ = new Filter();
  Generator::default_instance_ = new Generator();
  HashAgg::default_instance_ = new HashAgg();
  HashJoin::default_instance_ = new HashJoin();
  Limit::default_instance_ = new Limit();
  NestedLoopJoin::default_instance_ = new NestedLoopJoin();
  Project::default_instance_ = new Project();
  Sample::default_instance_ = new Sample();
  SetOp::default_instance_ = new SetOp();
  Sort::default_instance_ = new Sort();
  SortLimit::default_instance_ = new SortLimit();
  Emit::default_instance_ = new Emit();
  Relation::default_instance_ = new Relation();
  Query::default_instance_ = new Query();
  Distinct::default_instance_->InitAsDefaultInstance();
  Exchange::default_instance_->InitAsDefaultInstance();
  ExtScan::default_instance_->InitAsDefaultInstance();
  Filter::default_instance_->InitAsDefaultInstance();
  Generator::default_instance_->InitAsDefaultInstance();
  HashAgg::default_instance_->InitAsDefaultInstance();
  HashJoin::default_instance_->InitAsDefaultInstance();
  Limit::default_instance_->InitAsDefaultInstance();
  NestedLoopJoin::default_instance_->InitAsDefaultInstance();
  Project::default_instance_->InitAsDefaultInstance();
  Sample::default_instance_->InitAsDefaultInstance();
  SetOp::default_instance_->InitAsDefaultInstance();
  Sort::default_instance_->InitAsDefaultInstance();
  SortLimit::default_instance_->InitAsDefaultInstance();
  Emit::default_instance_->InitAsDefaultInstance();
  Relation::default_instance_->InitAsDefaultInstance();
  Query::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_query_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_query_2eproto {
  StaticDescriptorInitializer_query_2eproto() {
    protobuf_AddDesc_query_2eproto();
  }
} static_descriptor_initializer_query_2eproto_;
const ::google::protobuf::EnumDescriptor* JoinType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JoinType_descriptor_;
}
bool JoinType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Distinct::kIsPartialFieldNumber;
#endif  // !_MSC_VER

Distinct::Distinct()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Distinct::InitAsDefaultInstance() {
}

Distinct::Distinct(const Distinct& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Distinct::SharedCtor() {
  _cached_size_ = 0;
  is_partial_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Distinct::~Distinct() {
  SharedDtor();
}

void Distinct::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Distinct::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Distinct::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Distinct_descriptor_;
}

const Distinct& Distinct::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Distinct* Distinct::default_instance_ = NULL;

Distinct* Distinct::New() const {
  return new Distinct;
}

void Distinct::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    is_partial_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Distinct::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool is_partial = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_partial_)));
          set_has_is_partial();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Distinct::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool is_partial = 1;
  if (has_is_partial()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->is_partial(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Distinct::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool is_partial = 1;
  if (has_is_partial()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->is_partial(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Distinct::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool is_partial = 1;
    if (has_is_partial()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Distinct::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Distinct* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Distinct*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Distinct::MergeFrom(const Distinct& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_is_partial()) {
      set_is_partial(from.is_partial());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Distinct::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Distinct::CopyFrom(const Distinct& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Distinct::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Distinct::Swap(Distinct* other) {
  if (other != this) {
    std::swap(is_partial_, other->is_partial_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Distinct::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Distinct_descriptor_;
  metadata.reflection = Distinct_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Exchange_ExchangeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Exchange_ExchangeType_descriptor_;
}
bool Exchange_ExchangeType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Exchange_ExchangeType Exchange::BROADCAST;
const Exchange_ExchangeType Exchange::HASH;
const Exchange_ExchangeType Exchange::RANGE;
const Exchange_ExchangeType Exchange::ExchangeType_MIN;
const Exchange_ExchangeType Exchange::ExchangeType_MAX;
const int Exchange::ExchangeType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Exchange::kXTypeFieldNumber;
const int Exchange::kXPartFieldNumber;
const int Exchange::kXExprsFieldNumber;
const int Exchange::kXSortexprsFieldNumber;
#endif  // !_MSC_VER

Exchange::Exchange()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Exchange::InitAsDefaultInstance() {
}

Exchange::Exchange(const Exchange& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Exchange::SharedCtor() {
  _cached_size_ = 0;
  x_type_ = 0;
  x_part_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Exchange::~Exchange() {
  SharedDtor();
}

void Exchange::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Exchange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Exchange::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Exchange_descriptor_;
}

const Exchange& Exchange::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Exchange* Exchange::default_instance_ = NULL;

Exchange* Exchange::New() const {
  return new Exchange;
}

void Exchange::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_type_ = 0;
    x_part_ = 0;
  }
  x_exprs_.Clear();
  x_sortexprs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Exchange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .llql_proto.Exchange.ExchangeType x_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::llql_proto::Exchange_ExchangeType_IsValid(value)) {
            set_x_type(static_cast< ::llql_proto::Exchange_ExchangeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x_part;
        break;
      }

      // required int32 x_part = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x_part:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_part_)));
          set_has_x_part();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_x_exprs;
        break;
      }

      // repeated .llql_proto.Expr x_exprs = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_x_exprs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_x_exprs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_x_exprs;
        if (input->ExpectTag(34)) goto parse_x_sortexprs;
        break;
      }

      // repeated .llql_proto.SortExpr x_sortexprs = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_x_sortexprs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_x_sortexprs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_x_sortexprs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Exchange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .llql_proto.Exchange.ExchangeType x_type = 1;
  if (has_x_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->x_type(), output);
  }

  // required int32 x_part = 2;
  if (has_x_part()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x_part(), output);
  }

  // repeated .llql_proto.Expr x_exprs = 3;
  for (int i = 0; i < this->x_exprs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->x_exprs(i), output);
  }

  // repeated .llql_proto.SortExpr x_sortexprs = 4;
  for (int i = 0; i < this->x_sortexprs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->x_sortexprs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Exchange::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .llql_proto.Exchange.ExchangeType x_type = 1;
  if (has_x_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->x_type(), target);
  }

  // required int32 x_part = 2;
  if (has_x_part()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->x_part(), target);
  }

  // repeated .llql_proto.Expr x_exprs = 3;
  for (int i = 0; i < this->x_exprs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->x_exprs(i), target);
  }

  // repeated .llql_proto.SortExpr x_sortexprs = 4;
  for (int i = 0; i < this->x_sortexprs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->x_sortexprs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Exchange::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .llql_proto.Exchange.ExchangeType x_type = 1;
    if (has_x_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->x_type());
    }

    // required int32 x_part = 2;
    if (has_x_part()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x_part());
    }

  }
  // repeated .llql_proto.Expr x_exprs = 3;
  total_size += 1 * this->x_exprs_size();
  for (int i = 0; i < this->x_exprs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->x_exprs(i));
  }

  // repeated .llql_proto.SortExpr x_sortexprs = 4;
  total_size += 1 * this->x_sortexprs_size();
  for (int i = 0; i < this->x_sortexprs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->x_sortexprs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Exchange::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Exchange* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Exchange*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Exchange::MergeFrom(const Exchange& from) {
  GOOGLE_CHECK_NE(&from, this);
  x_exprs_.MergeFrom(from.x_exprs_);
  x_sortexprs_.MergeFrom(from.x_sortexprs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x_type()) {
      set_x_type(from.x_type());
    }
    if (from.has_x_part()) {
      set_x_part(from.x_part());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Exchange::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Exchange::CopyFrom(const Exchange& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Exchange::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < x_exprs_size(); i++) {
    if (!this->x_exprs(i).IsInitialized()) return false;
  }
  for (int i = 0; i < x_sortexprs_size(); i++) {
    if (!this->x_sortexprs(i).IsInitialized()) return false;
  }
  return true;
}

void Exchange::Swap(Exchange* other) {
  if (other != this) {
    std::swap(x_type_, other->x_type_);
    std::swap(x_part_, other->x_part_);
    x_exprs_.Swap(&other->x_exprs_);
    x_sortexprs_.Swap(&other->x_sortexprs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Exchange::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Exchange_descriptor_;
  metadata.reflection = Exchange_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ExtScan_DSType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExtScan_DSType_descriptor_;
}
bool ExtScan_DSType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ExtScan_DSType ExtScan::CSV;
const ExtScan_DSType ExtScan::PG_TEXT;
const ExtScan_DSType ExtScan::PARQUET;
const ExtScan_DSType ExtScan::DSType_MIN;
const ExtScan_DSType ExtScan::DSType_MAX;
const int ExtScan::DSType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ExtScan::kDsTypeFieldNumber;
const int ExtScan::kUrlsFieldNumber;
const int ExtScan::kColsFieldNumber;
#endif  // !_MSC_VER

ExtScan::ExtScan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ExtScan::InitAsDefaultInstance() {
  cols_ = const_cast< ::llql_proto::Schema*>(&::llql_proto::Schema::default_instance());
}

ExtScan::ExtScan(const ExtScan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ExtScan::SharedCtor() {
  _cached_size_ = 0;
  ds_type_ = 0;
  cols_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExtScan::~ExtScan() {
  SharedDtor();
}

void ExtScan::SharedDtor() {
  if (this != default_instance_) {
    delete cols_;
  }
}

void ExtScan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExtScan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExtScan_descriptor_;
}

const ExtScan& ExtScan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

ExtScan* ExtScan::default_instance_ = NULL;

ExtScan* ExtScan::New() const {
  return new ExtScan;
}

void ExtScan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ds_type_ = 0;
    if (has_cols()) {
      if (cols_ != NULL) cols_->::llql_proto::Schema::Clear();
    }
  }
  urls_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExtScan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .llql_proto.ExtScan.DSType ds_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::llql_proto::ExtScan_DSType_IsValid(value)) {
            set_ds_type(static_cast< ::llql_proto::ExtScan_DSType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_urls;
        break;
      }

      // repeated string urls = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_urls:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_urls()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->urls(this->urls_size() - 1).data(),
            this->urls(this->urls_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_urls;
        if (input->ExpectTag(26)) goto parse_cols;
        break;
      }

      // required .llql_proto.Schema cols = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cols:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cols()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExtScan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .llql_proto.ExtScan.DSType ds_type = 1;
  if (has_ds_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->ds_type(), output);
  }

  // repeated string urls = 2;
  for (int i = 0; i < this->urls_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->urls(i).data(), this->urls(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->urls(i), output);
  }

  // required .llql_proto.Schema cols = 3;
  if (has_cols()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->cols(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ExtScan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .llql_proto.ExtScan.DSType ds_type = 1;
  if (has_ds_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->ds_type(), target);
  }

  // repeated string urls = 2;
  for (int i = 0; i < this->urls_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->urls(i).data(), this->urls(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->urls(i), target);
  }

  // required .llql_proto.Schema cols = 3;
  if (has_cols()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->cols(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ExtScan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .llql_proto.ExtScan.DSType ds_type = 1;
    if (has_ds_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ds_type());
    }

    // required .llql_proto.Schema cols = 3;
    if (has_cols()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cols());
    }

  }
  // repeated string urls = 2;
  total_size += 1 * this->urls_size();
  for (int i = 0; i < this->urls_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->urls(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExtScan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExtScan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExtScan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExtScan::MergeFrom(const ExtScan& from) {
  GOOGLE_CHECK_NE(&from, this);
  urls_.MergeFrom(from.urls_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ds_type()) {
      set_ds_type(from.ds_type());
    }
    if (from.has_cols()) {
      mutable_cols()->::llql_proto::Schema::MergeFrom(from.cols());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExtScan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExtScan::CopyFrom(const ExtScan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtScan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  if (has_cols()) {
    if (!this->cols().IsInitialized()) return false;
  }
  return true;
}

void ExtScan::Swap(ExtScan* other) {
  if (other != this) {
    std::swap(ds_type_, other->ds_type_);
    urls_.Swap(&other->urls_);
    std::swap(cols_, other->cols_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExtScan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExtScan_descriptor_;
  metadata.reflection = ExtScan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Filter::kPredicateFieldNumber;
#endif  // !_MSC_VER

Filter::Filter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Filter::InitAsDefaultInstance() {
  predicate_ = const_cast< ::llql_proto::Expr*>(&::llql_proto::Expr::default_instance());
}

Filter::Filter(const Filter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Filter::SharedCtor() {
  _cached_size_ = 0;
  predicate_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Filter::~Filter() {
  SharedDtor();
}

void Filter::SharedDtor() {
  if (this != default_instance_) {
    delete predicate_;
  }
}

void Filter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Filter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Filter_descriptor_;
}

const Filter& Filter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Filter* Filter::default_instance_ = NULL;

Filter* Filter::New() const {
  return new Filter;
}

void Filter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_predicate()) {
      if (predicate_ != NULL) predicate_->::llql_proto::Expr::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Filter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .llql_proto.Expr predicate = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_predicate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Filter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .llql_proto.Expr predicate = 1;
  if (has_predicate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->predicate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Filter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .llql_proto.Expr predicate = 1;
  if (has_predicate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->predicate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Filter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .llql_proto.Expr predicate = 1;
    if (has_predicate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->predicate());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Filter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Filter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Filter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Filter::MergeFrom(const Filter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_predicate()) {
      mutable_predicate()->::llql_proto::Expr::MergeFrom(from.predicate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Filter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Filter::CopyFrom(const Filter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Filter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_predicate()) {
    if (!this->predicate().IsInitialized()) return false;
  }
  return true;
}

void Filter::Swap(Filter* other) {
  if (other != this) {
    std::swap(predicate_, other->predicate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Filter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Filter_descriptor_;
  metadata.reflection = Filter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Generator::kExpandArrayFieldNumber;
const int Generator::kGenFunctionFieldNumber;
#endif  // !_MSC_VER

Generator::Generator()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Generator::InitAsDefaultInstance() {
  gen_function_ = const_cast< ::llql_proto::Expr*>(&::llql_proto::Expr::default_instance());
}

Generator::Generator(const Generator& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Generator::SharedCtor() {
  _cached_size_ = 0;
  gen_function_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Generator::~Generator() {
  SharedDtor();
}

void Generator::SharedDtor() {
  if (this != default_instance_) {
    delete gen_function_;
  }
}

void Generator::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Generator::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Generator_descriptor_;
}

const Generator& Generator::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Generator* Generator::default_instance_ = NULL;

Generator* Generator::New() const {
  return new Generator;
}

void Generator::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_gen_function()) {
      if (gen_function_ != NULL) gen_function_->::llql_proto::Expr::Clear();
    }
  }
  expand_array_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Generator::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .llql_proto.Expr expand_array = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_expand_array:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_expand_array()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_expand_array;
        if (input->ExpectTag(18)) goto parse_gen_function;
        break;
      }

      // optional .llql_proto.Expr gen_function = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gen_function:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gen_function()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Generator::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .llql_proto.Expr expand_array = 1;
  for (int i = 0; i < this->expand_array_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->expand_array(i), output);
  }

  // optional .llql_proto.Expr gen_function = 2;
  if (has_gen_function()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->gen_function(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Generator::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .llql_proto.Expr expand_array = 1;
  for (int i = 0; i < this->expand_array_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->expand_array(i), target);
  }

  // optional .llql_proto.Expr gen_function = 2;
  if (has_gen_function()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->gen_function(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Generator::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .llql_proto.Expr gen_function = 2;
    if (has_gen_function()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gen_function());
    }

  }
  // repeated .llql_proto.Expr expand_array = 1;
  total_size += 1 * this->expand_array_size();
  for (int i = 0; i < this->expand_array_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->expand_array(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Generator::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Generator* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Generator*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Generator::MergeFrom(const Generator& from) {
  GOOGLE_CHECK_NE(&from, this);
  expand_array_.MergeFrom(from.expand_array_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_gen_function()) {
      mutable_gen_function()->::llql_proto::Expr::MergeFrom(from.gen_function());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Generator::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Generator::CopyFrom(const Generator& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Generator::IsInitialized() const {

  for (int i = 0; i < expand_array_size(); i++) {
    if (!this->expand_array(i).IsInitialized()) return false;
  }
  if (has_gen_function()) {
    if (!this->gen_function().IsInitialized()) return false;
  }
  return true;
}

void Generator::Swap(Generator* other) {
  if (other != this) {
    expand_array_.Swap(&other->expand_array_);
    std::swap(gen_function_, other->gen_function_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Generator::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Generator_descriptor_;
  metadata.reflection = Generator_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HashAgg::kIsPartialFieldNumber;
const int HashAgg::kIsTopFieldNumber;
const int HashAgg::kGrpExprsFieldNumber;
const int HashAgg::kProjExprsFieldNumber;
#endif  // !_MSC_VER

HashAgg::HashAgg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HashAgg::InitAsDefaultInstance() {
}

HashAgg::HashAgg(const HashAgg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HashAgg::SharedCtor() {
  _cached_size_ = 0;
  is_partial_ = false;
  is_top_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HashAgg::~HashAgg() {
  SharedDtor();
}

void HashAgg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HashAgg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HashAgg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HashAgg_descriptor_;
}

const HashAgg& HashAgg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

HashAgg* HashAgg::default_instance_ = NULL;

HashAgg* HashAgg::New() const {
  return new HashAgg;
}

void HashAgg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    is_partial_ = false;
    is_top_ = false;
  }
  grp_exprs_.Clear();
  proj_exprs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HashAgg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool is_partial = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_partial_)));
          set_has_is_partial();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_top;
        break;
      }

      // required bool is_top = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_top:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_top_)));
          set_has_is_top();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_grp_exprs;
        break;
      }

      // repeated .llql_proto.Expr grp_exprs = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_grp_exprs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_grp_exprs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_grp_exprs;
        if (input->ExpectTag(34)) goto parse_proj_exprs;
        break;
      }

      // repeated .llql_proto.Expr proj_exprs = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_proj_exprs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_proj_exprs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_proj_exprs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HashAgg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool is_partial = 1;
  if (has_is_partial()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->is_partial(), output);
  }

  // required bool is_top = 2;
  if (has_is_top()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_top(), output);
  }

  // repeated .llql_proto.Expr grp_exprs = 3;
  for (int i = 0; i < this->grp_exprs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->grp_exprs(i), output);
  }

  // repeated .llql_proto.Expr proj_exprs = 4;
  for (int i = 0; i < this->proj_exprs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->proj_exprs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HashAgg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool is_partial = 1;
  if (has_is_partial()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->is_partial(), target);
  }

  // required bool is_top = 2;
  if (has_is_top()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->is_top(), target);
  }

  // repeated .llql_proto.Expr grp_exprs = 3;
  for (int i = 0; i < this->grp_exprs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->grp_exprs(i), target);
  }

  // repeated .llql_proto.Expr proj_exprs = 4;
  for (int i = 0; i < this->proj_exprs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->proj_exprs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HashAgg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool is_partial = 1;
    if (has_is_partial()) {
      total_size += 1 + 1;
    }

    // required bool is_top = 2;
    if (has_is_top()) {
      total_size += 1 + 1;
    }

  }
  // repeated .llql_proto.Expr grp_exprs = 3;
  total_size += 1 * this->grp_exprs_size();
  for (int i = 0; i < this->grp_exprs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->grp_exprs(i));
  }

  // repeated .llql_proto.Expr proj_exprs = 4;
  total_size += 1 * this->proj_exprs_size();
  for (int i = 0; i < this->proj_exprs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->proj_exprs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HashAgg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HashAgg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HashAgg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HashAgg::MergeFrom(const HashAgg& from) {
  GOOGLE_CHECK_NE(&from, this);
  grp_exprs_.MergeFrom(from.grp_exprs_);
  proj_exprs_.MergeFrom(from.proj_exprs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_is_partial()) {
      set_is_partial(from.is_partial());
    }
    if (from.has_is_top()) {
      set_is_top(from.is_top());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HashAgg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HashAgg::CopyFrom(const HashAgg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashAgg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < grp_exprs_size(); i++) {
    if (!this->grp_exprs(i).IsInitialized()) return false;
  }
  for (int i = 0; i < proj_exprs_size(); i++) {
    if (!this->proj_exprs(i).IsInitialized()) return false;
  }
  return true;
}

void HashAgg::Swap(HashAgg* other) {
  if (other != this) {
    std::swap(is_partial_, other->is_partial_);
    std::swap(is_top_, other->is_top_);
    grp_exprs_.Swap(&other->grp_exprs_);
    proj_exprs_.Swap(&other->proj_exprs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HashAgg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HashAgg_descriptor_;
  metadata.reflection = HashAgg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HashJoin::kLeftKeysFieldNumber;
const int HashJoin::kRightKeysFieldNumber;
const int HashJoin::kBuildSideFieldNumber;
const int HashJoin::kJoinTypeFieldNumber;
const int HashJoin::kExtraPredicateFieldNumber;
const int HashJoin::kBroadcastFieldNumber;
#endif  // !_MSC_VER

HashJoin::HashJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HashJoin::InitAsDefaultInstance() {
  extra_predicate_ = const_cast< ::llql_proto::Expr*>(&::llql_proto::Expr::default_instance());
}

HashJoin::HashJoin(const HashJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HashJoin::SharedCtor() {
  _cached_size_ = 0;
  build_side_ = 0;
  join_type_ = 0;
  extra_predicate_ = NULL;
  broadcast_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HashJoin::~HashJoin() {
  SharedDtor();
}

void HashJoin::SharedDtor() {
  if (this != default_instance_) {
    delete extra_predicate_;
  }
}

void HashJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HashJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HashJoin_descriptor_;
}

const HashJoin& HashJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

HashJoin* HashJoin::default_instance_ = NULL;

HashJoin* HashJoin::New() const {
  return new HashJoin;
}

void HashJoin::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    build_side_ = 0;
    join_type_ = 0;
    if (has_extra_predicate()) {
      if (extra_predicate_ != NULL) extra_predicate_->::llql_proto::Expr::Clear();
    }
    broadcast_ = false;
  }
  left_keys_.Clear();
  right_keys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HashJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .llql_proto.Expr left_keys = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_left_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_left_keys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_left_keys;
        if (input->ExpectTag(18)) goto parse_right_keys;
        break;
      }

      // repeated .llql_proto.Expr right_keys = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_right_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_right_keys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_right_keys;
        if (input->ExpectTag(24)) goto parse_build_side;
        break;
      }

      // required int32 build_side = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_build_side:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &build_side_)));
          set_has_build_side();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_join_type;
        break;
      }

      // required .llql_proto.JoinType join_type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_join_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::llql_proto::JoinType_IsValid(value)) {
            set_join_type(static_cast< ::llql_proto::JoinType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_extra_predicate;
        break;
      }

      // optional .llql_proto.Expr extra_predicate = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_extra_predicate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_extra_predicate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_broadcast;
        break;
      }

      // required bool broadcast = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_broadcast:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &broadcast_)));
          set_has_broadcast();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HashJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .llql_proto.Expr left_keys = 1;
  for (int i = 0; i < this->left_keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->left_keys(i), output);
  }

  // repeated .llql_proto.Expr right_keys = 2;
  for (int i = 0; i < this->right_keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->right_keys(i), output);
  }

  // required int32 build_side = 3;
  if (has_build_side()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->build_side(), output);
  }

  // required .llql_proto.JoinType join_type = 4;
  if (has_join_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->join_type(), output);
  }

  // optional .llql_proto.Expr extra_predicate = 5;
  if (has_extra_predicate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->extra_predicate(), output);
  }

  // required bool broadcast = 6;
  if (has_broadcast()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->broadcast(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HashJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .llql_proto.Expr left_keys = 1;
  for (int i = 0; i < this->left_keys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->left_keys(i), target);
  }

  // repeated .llql_proto.Expr right_keys = 2;
  for (int i = 0; i < this->right_keys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->right_keys(i), target);
  }

  // required int32 build_side = 3;
  if (has_build_side()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->build_side(), target);
  }

  // required .llql_proto.JoinType join_type = 4;
  if (has_join_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->join_type(), target);
  }

  // optional .llql_proto.Expr extra_predicate = 5;
  if (has_extra_predicate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->extra_predicate(), target);
  }

  // required bool broadcast = 6;
  if (has_broadcast()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->broadcast(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HashJoin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // required int32 build_side = 3;
    if (has_build_side()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->build_side());
    }

    // required .llql_proto.JoinType join_type = 4;
    if (has_join_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->join_type());
    }

    // optional .llql_proto.Expr extra_predicate = 5;
    if (has_extra_predicate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->extra_predicate());
    }

    // required bool broadcast = 6;
    if (has_broadcast()) {
      total_size += 1 + 1;
    }

  }
  // repeated .llql_proto.Expr left_keys = 1;
  total_size += 1 * this->left_keys_size();
  for (int i = 0; i < this->left_keys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->left_keys(i));
  }

  // repeated .llql_proto.Expr right_keys = 2;
  total_size += 1 * this->right_keys_size();
  for (int i = 0; i < this->right_keys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->right_keys(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HashJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HashJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HashJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HashJoin::MergeFrom(const HashJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  left_keys_.MergeFrom(from.left_keys_);
  right_keys_.MergeFrom(from.right_keys_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_build_side()) {
      set_build_side(from.build_side());
    }
    if (from.has_join_type()) {
      set_join_type(from.join_type());
    }
    if (from.has_extra_predicate()) {
      mutable_extra_predicate()->::llql_proto::Expr::MergeFrom(from.extra_predicate());
    }
    if (from.has_broadcast()) {
      set_broadcast(from.broadcast());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HashJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HashJoin::CopyFrom(const HashJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000002c) != 0x0000002c) return false;

  for (int i = 0; i < left_keys_size(); i++) {
    if (!this->left_keys(i).IsInitialized()) return false;
  }
  for (int i = 0; i < right_keys_size(); i++) {
    if (!this->right_keys(i).IsInitialized()) return false;
  }
  if (has_extra_predicate()) {
    if (!this->extra_predicate().IsInitialized()) return false;
  }
  return true;
}

void HashJoin::Swap(HashJoin* other) {
  if (other != this) {
    left_keys_.Swap(&other->left_keys_);
    right_keys_.Swap(&other->right_keys_);
    std::swap(build_side_, other->build_side_);
    std::swap(join_type_, other->join_type_);
    std::swap(extra_predicate_, other->extra_predicate_);
    std::swap(broadcast_, other->broadcast_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HashJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HashJoin_descriptor_;
  metadata.reflection = HashJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Limit::kLimitFieldNumber;
const int Limit::kOffsetFieldNumber;
#endif  // !_MSC_VER

Limit::Limit()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Limit::InitAsDefaultInstance() {
}

Limit::Limit(const Limit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Limit::SharedCtor() {
  _cached_size_ = 0;
  limit_ = GOOGLE_LONGLONG(0);
  offset_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Limit::~Limit() {
  SharedDtor();
}

void Limit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Limit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Limit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Limit_descriptor_;
}

const Limit& Limit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Limit* Limit::default_instance_ = NULL;

Limit* Limit::New() const {
  return new Limit;
}

void Limit::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    limit_ = GOOGLE_LONGLONG(0);
    offset_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Limit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 limit = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &limit_)));
          set_has_limit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_offset;
        break;
      }

      // required int64 offset = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Limit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 limit = 1;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->limit(), output);
  }

  // required int64 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->offset(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Limit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 limit = 1;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->limit(), target);
  }

  // required int64 offset = 2;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->offset(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Limit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 limit = 1;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->limit());
    }

    // required int64 offset = 2;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->offset());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Limit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Limit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Limit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Limit::MergeFrom(const Limit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_limit()) {
      set_limit(from.limit());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Limit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Limit::CopyFrom(const Limit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Limit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Limit::Swap(Limit* other) {
  if (other != this) {
    std::swap(limit_, other->limit_);
    std::swap(offset_, other->offset_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Limit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Limit_descriptor_;
  metadata.reflection = Limit_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NestedLoopJoin::kBuildSideFieldNumber;
const int NestedLoopJoin::kJoinTypeFieldNumber;
const int NestedLoopJoin::kPredicateFieldNumber;
const int NestedLoopJoin::kBroadcastFieldNumber;
#endif  // !_MSC_VER

NestedLoopJoin::NestedLoopJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NestedLoopJoin::InitAsDefaultInstance() {
  predicate_ = const_cast< ::llql_proto::Expr*>(&::llql_proto::Expr::default_instance());
}

NestedLoopJoin::NestedLoopJoin(const NestedLoopJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NestedLoopJoin::SharedCtor() {
  _cached_size_ = 0;
  build_side_ = 0;
  join_type_ = 0;
  predicate_ = NULL;
  broadcast_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NestedLoopJoin::~NestedLoopJoin() {
  SharedDtor();
}

void NestedLoopJoin::SharedDtor() {
  if (this != default_instance_) {
    delete predicate_;
  }
}

void NestedLoopJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NestedLoopJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NestedLoopJoin_descriptor_;
}

const NestedLoopJoin& NestedLoopJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

NestedLoopJoin* NestedLoopJoin::default_instance_ = NULL;

NestedLoopJoin* NestedLoopJoin::New() const {
  return new NestedLoopJoin;
}

void NestedLoopJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    build_side_ = 0;
    join_type_ = 0;
    if (has_predicate()) {
      if (predicate_ != NULL) predicate_->::llql_proto::Expr::Clear();
    }
    broadcast_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NestedLoopJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 build_side = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &build_side_)));
          set_has_build_side();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_join_type;
        break;
      }

      // required .llql_proto.JoinType join_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_join_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::llql_proto::JoinType_IsValid(value)) {
            set_join_type(static_cast< ::llql_proto::JoinType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_predicate;
        break;
      }

      // optional .llql_proto.Expr predicate = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_predicate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_predicate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_broadcast;
        break;
      }

      // required bool broadcast = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_broadcast:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &broadcast_)));
          set_has_broadcast();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NestedLoopJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 build_side = 1;
  if (has_build_side()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->build_side(), output);
  }

  // required .llql_proto.JoinType join_type = 2;
  if (has_join_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->join_type(), output);
  }

  // optional .llql_proto.Expr predicate = 3;
  if (has_predicate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->predicate(), output);
  }

  // required bool broadcast = 4;
  if (has_broadcast()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->broadcast(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NestedLoopJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 build_side = 1;
  if (has_build_side()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->build_side(), target);
  }

  // required .llql_proto.JoinType join_type = 2;
  if (has_join_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->join_type(), target);
  }

  // optional .llql_proto.Expr predicate = 3;
  if (has_predicate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->predicate(), target);
  }

  // required bool broadcast = 4;
  if (has_broadcast()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->broadcast(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NestedLoopJoin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 build_side = 1;
    if (has_build_side()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->build_side());
    }

    // required .llql_proto.JoinType join_type = 2;
    if (has_join_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->join_type());
    }

    // optional .llql_proto.Expr predicate = 3;
    if (has_predicate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->predicate());
    }

    // required bool broadcast = 4;
    if (has_broadcast()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NestedLoopJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NestedLoopJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NestedLoopJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NestedLoopJoin::MergeFrom(const NestedLoopJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_build_side()) {
      set_build_side(from.build_side());
    }
    if (from.has_join_type()) {
      set_join_type(from.join_type());
    }
    if (from.has_predicate()) {
      mutable_predicate()->::llql_proto::Expr::MergeFrom(from.predicate());
    }
    if (from.has_broadcast()) {
      set_broadcast(from.broadcast());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NestedLoopJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NestedLoopJoin::CopyFrom(const NestedLoopJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NestedLoopJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;

  if (has_predicate()) {
    if (!this->predicate().IsInitialized()) return false;
  }
  return true;
}

void NestedLoopJoin::Swap(NestedLoopJoin* other) {
  if (other != this) {
    std::swap(build_side_, other->build_side_);
    std::swap(join_type_, other->join_type_);
    std::swap(predicate_, other->predicate_);
    std::swap(broadcast_, other->broadcast_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NestedLoopJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NestedLoopJoin_descriptor_;
  metadata.reflection = NestedLoopJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Project::kExprsFieldNumber;
#endif  // !_MSC_VER

Project::Project()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Project::InitAsDefaultInstance() {
}

Project::Project(const Project& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Project::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Project::~Project() {
  SharedDtor();
}

void Project::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Project::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Project::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Project_descriptor_;
}

const Project& Project::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Project* Project::default_instance_ = NULL;

Project* Project::New() const {
  return new Project;
}

void Project::Clear() {
  exprs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Project::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .llql_proto.Expr exprs = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exprs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exprs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_exprs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Project::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .llql_proto.Expr exprs = 1;
  for (int i = 0; i < this->exprs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->exprs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Project::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .llql_proto.Expr exprs = 1;
  for (int i = 0; i < this->exprs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->exprs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Project::ByteSize() const {
  int total_size = 0;

  // repeated .llql_proto.Expr exprs = 1;
  total_size += 1 * this->exprs_size();
  for (int i = 0; i < this->exprs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exprs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Project::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Project* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Project*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Project::MergeFrom(const Project& from) {
  GOOGLE_CHECK_NE(&from, this);
  exprs_.MergeFrom(from.exprs_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Project::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Project::CopyFrom(const Project& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Project::IsInitialized() const {

  for (int i = 0; i < exprs_size(); i++) {
    if (!this->exprs(i).IsInitialized()) return false;
  }
  return true;
}

void Project::Swap(Project* other) {
  if (other != this) {
    exprs_.Swap(&other->exprs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Project::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Project_descriptor_;
  metadata.reflection = Project_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Sample::kFractionFieldNumber;
const int Sample::kWithReplacementFieldNumber;
const int Sample::kSeedFieldNumber;
#endif  // !_MSC_VER

Sample::Sample()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Sample::InitAsDefaultInstance() {
}

Sample::Sample(const Sample& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Sample::SharedCtor() {
  _cached_size_ = 0;
  fraction_ = 0;
  with_replacement_ = false;
  seed_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sample::~Sample() {
  SharedDtor();
}

void Sample::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Sample::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sample::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sample_descriptor_;
}

const Sample& Sample::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Sample* Sample::default_instance_ = NULL;

Sample* Sample::New() const {
  return new Sample;
}

void Sample::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    fraction_ = 0;
    with_replacement_ = false;
    seed_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Sample::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double fraction = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fraction_)));
          set_has_fraction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_with_replacement;
        break;
      }

      // required bool with_replacement = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_with_replacement:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &with_replacement_)));
          set_has_with_replacement();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_seed;
        break;
      }

      // required int64 seed = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &seed_)));
          set_has_seed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Sample::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double fraction = 1;
  if (has_fraction()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->fraction(), output);
  }

  // required bool with_replacement = 2;
  if (has_with_replacement()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->with_replacement(), output);
  }

  // required int64 seed = 3;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->seed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Sample::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double fraction = 1;
  if (has_fraction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->fraction(), target);
  }

  // required bool with_replacement = 2;
  if (has_with_replacement()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->with_replacement(), target);
  }

  // required int64 seed = 3;
  if (has_seed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->seed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Sample::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double fraction = 1;
    if (has_fraction()) {
      total_size += 1 + 8;
    }

    // required bool with_replacement = 2;
    if (has_with_replacement()) {
      total_size += 1 + 1;
    }

    // required int64 seed = 3;
    if (has_seed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->seed());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sample::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Sample* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Sample*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sample::MergeFrom(const Sample& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fraction()) {
      set_fraction(from.fraction());
    }
    if (from.has_with_replacement()) {
      set_with_replacement(from.with_replacement());
    }
    if (from.has_seed()) {
      set_seed(from.seed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Sample::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sample::CopyFrom(const Sample& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sample::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Sample::Swap(Sample* other) {
  if (other != this) {
    std::swap(fraction_, other->fraction_);
    std::swap(with_replacement_, other->with_replacement_);
    std::swap(seed_, other->seed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Sample::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sample_descriptor_;
  metadata.reflection = Sample_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SetOp_SetOpType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetOp_SetOpType_descriptor_;
}
bool SetOp_SetOpType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SetOp_SetOpType SetOp::UNION;
const SetOp_SetOpType SetOp::UNION_ALL;
const SetOp_SetOpType SetOp::INTERSECT;
const SetOp_SetOpType SetOp::EXCEPT;
const SetOp_SetOpType SetOp::SetOpType_MIN;
const SetOp_SetOpType SetOp::SetOpType_MAX;
const int SetOp::SetOpType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SetOp::kSetopTypeFieldNumber;
#endif  // !_MSC_VER

SetOp::SetOp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SetOp::InitAsDefaultInstance() {
}

SetOp::SetOp(const SetOp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SetOp::SharedCtor() {
  _cached_size_ = 0;
  setop_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetOp::~SetOp() {
  SharedDtor();
}

void SetOp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SetOp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetOp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetOp_descriptor_;
}

const SetOp& SetOp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

SetOp* SetOp::default_instance_ = NULL;

SetOp* SetOp::New() const {
  return new SetOp;
}

void SetOp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    setop_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SetOp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .llql_proto.SetOp.SetOpType setop_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::llql_proto::SetOp_SetOpType_IsValid(value)) {
            set_setop_type(static_cast< ::llql_proto::SetOp_SetOpType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SetOp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .llql_proto.SetOp.SetOpType setop_type = 1;
  if (has_setop_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->setop_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SetOp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .llql_proto.SetOp.SetOpType setop_type = 1;
  if (has_setop_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->setop_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SetOp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .llql_proto.SetOp.SetOpType setop_type = 1;
    if (has_setop_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->setop_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetOp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SetOp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SetOp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SetOp::MergeFrom(const SetOp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_setop_type()) {
      set_setop_type(from.setop_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SetOp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetOp::CopyFrom(const SetOp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetOp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SetOp::Swap(SetOp* other) {
  if (other != this) {
    std::swap(setop_type_, other->setop_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SetOp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SetOp_descriptor_;
  metadata.reflection = SetOp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Sort::kSortExprsFieldNumber;
#endif  // !_MSC_VER

Sort::Sort()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Sort::InitAsDefaultInstance() {
}

Sort::Sort(const Sort& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Sort::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sort::~Sort() {
  SharedDtor();
}

void Sort::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Sort::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sort::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sort_descriptor_;
}

const Sort& Sort::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Sort* Sort::default_instance_ = NULL;

Sort* Sort::New() const {
  return new Sort;
}

void Sort::Clear() {
  sort_exprs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Sort::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .llql_proto.SortExpr sort_exprs = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sort_exprs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sort_exprs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_sort_exprs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Sort::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .llql_proto.SortExpr sort_exprs = 1;
  for (int i = 0; i < this->sort_exprs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sort_exprs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Sort::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .llql_proto.SortExpr sort_exprs = 1;
  for (int i = 0; i < this->sort_exprs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sort_exprs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Sort::ByteSize() const {
  int total_size = 0;

  // repeated .llql_proto.SortExpr sort_exprs = 1;
  total_size += 1 * this->sort_exprs_size();
  for (int i = 0; i < this->sort_exprs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sort_exprs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sort::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Sort* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Sort*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sort::MergeFrom(const Sort& from) {
  GOOGLE_CHECK_NE(&from, this);
  sort_exprs_.MergeFrom(from.sort_exprs_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Sort::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sort::CopyFrom(const Sort& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sort::IsInitialized() const {

  for (int i = 0; i < sort_exprs_size(); i++) {
    if (!this->sort_exprs(i).IsInitialized()) return false;
  }
  return true;
}

void Sort::Swap(Sort* other) {
  if (other != this) {
    sort_exprs_.Swap(&other->sort_exprs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Sort::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sort_descriptor_;
  metadata.reflection = Sort_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SortLimit::kSortExprsFieldNumber;
const int SortLimit::kLimitFieldNumber;
const int SortLimit::kOffsetFieldNumber;
#endif  // !_MSC_VER

SortLimit::SortLimit()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SortLimit::InitAsDefaultInstance() {
}

SortLimit::SortLimit(const SortLimit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SortLimit::SharedCtor() {
  _cached_size_ = 0;
  limit_ = GOOGLE_LONGLONG(0);
  offset_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SortLimit::~SortLimit() {
  SharedDtor();
}

void SortLimit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SortLimit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SortLimit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SortLimit_descriptor_;
}

const SortLimit& SortLimit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

SortLimit* SortLimit::default_instance_ = NULL;

SortLimit* SortLimit::New() const {
  return new SortLimit;
}

void SortLimit::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    limit_ = GOOGLE_LONGLONG(0);
    offset_ = GOOGLE_LONGLONG(0);
  }
  sort_exprs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SortLimit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .llql_proto.SortExpr sort_exprs = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sort_exprs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sort_exprs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_sort_exprs;
        if (input->ExpectTag(16)) goto parse_limit;
        break;
      }

      // required int64 limit = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &limit_)));
          set_has_limit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_offset;
        break;
      }

      // required int64 offset = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SortLimit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .llql_proto.SortExpr sort_exprs = 1;
  for (int i = 0; i < this->sort_exprs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sort_exprs(i), output);
  }

  // required int64 limit = 2;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->limit(), output);
  }

  // required int64 offset = 3;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->offset(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SortLimit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .llql_proto.SortExpr sort_exprs = 1;
  for (int i = 0; i < this->sort_exprs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sort_exprs(i), target);
  }

  // required int64 limit = 2;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->limit(), target);
  }

  // required int64 offset = 3;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->offset(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SortLimit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required int64 limit = 2;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->limit());
    }

    // required int64 offset = 3;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->offset());
    }

  }
  // repeated .llql_proto.SortExpr sort_exprs = 1;
  total_size += 1 * this->sort_exprs_size();
  for (int i = 0; i < this->sort_exprs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sort_exprs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SortLimit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SortLimit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SortLimit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SortLimit::MergeFrom(const SortLimit& from) {
  GOOGLE_CHECK_NE(&from, this);
  sort_exprs_.MergeFrom(from.sort_exprs_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_limit()) {
      set_limit(from.limit());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SortLimit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SortLimit::CopyFrom(const SortLimit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SortLimit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  for (int i = 0; i < sort_exprs_size(); i++) {
    if (!this->sort_exprs(i).IsInitialized()) return false;
  }
  return true;
}

void SortLimit::Swap(SortLimit* other) {
  if (other != this) {
    sort_exprs_.Swap(&other->sort_exprs_);
    std::swap(limit_, other->limit_);
    std::swap(offset_, other->offset_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SortLimit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SortLimit_descriptor_;
  metadata.reflection = SortLimit_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Emit::kLimitFieldNumber;
const int Emit::kOffsetFieldNumber;
const int Emit::kSampleRateFieldNumber;
#endif  // !_MSC_VER

Emit::Emit()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Emit::InitAsDefaultInstance() {
}

Emit::Emit(const Emit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Emit::SharedCtor() {
  _cached_size_ = 0;
  limit_ = GOOGLE_LONGLONG(0);
  offset_ = GOOGLE_LONGLONG(0);
  sample_rate_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Emit::~Emit() {
  SharedDtor();
}

void Emit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Emit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Emit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Emit_descriptor_;
}

const Emit& Emit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Emit* Emit::default_instance_ = NULL;

Emit* Emit::New() const {
  return new Emit;
}

void Emit::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    limit_ = GOOGLE_LONGLONG(0);
    offset_ = GOOGLE_LONGLONG(0);
    sample_rate_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Emit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 limit = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &limit_)));
          set_has_limit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_offset;
        break;
      }

      // required int64 offset = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sample_rate;
        break;
      }

      // required int64 sample_rate = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sample_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sample_rate_)));
          set_has_sample_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Emit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 limit = 1;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->limit(), output);
  }

  // required int64 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->offset(), output);
  }

  // required int64 sample_rate = 3;
  if (has_sample_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->sample_rate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Emit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 limit = 1;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->limit(), target);
  }

  // required int64 offset = 2;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->offset(), target);
  }

  // required int64 sample_rate = 3;
  if (has_sample_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->sample_rate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Emit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 limit = 1;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->limit());
    }

    // required int64 offset = 2;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->offset());
    }

    // required int64 sample_rate = 3;
    if (has_sample_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sample_rate());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Emit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Emit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Emit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Emit::MergeFrom(const Emit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_limit()) {
      set_limit(from.limit());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_sample_rate()) {
      set_sample_rate(from.sample_rate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Emit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Emit::CopyFrom(const Emit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Emit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Emit::Swap(Emit* other) {
  if (other != this) {
    std::swap(limit_, other->limit_);
    std::swap(offset_, other->offset_);
    std::swap(sample_rate_, other->sample_rate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Emit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Emit_descriptor_;
  metadata.reflection = Emit_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Relation::kRelIdFieldNumber;
const int Relation::kRelNameFieldNumber;
const int Relation::kSchemaFieldNumber;
const int Relation::kChildrenFieldNumber;
const int Relation::kDistinctFieldNumber;
const int Relation::kExchangeFieldNumber;
const int Relation::kExtscanFieldNumber;
const int Relation::kFilterFieldNumber;
const int Relation::kGeneratorFieldNumber;
const int Relation::kHashaggFieldNumber;
const int Relation::kHashjoinFieldNumber;
const int Relation::kLimitFieldNumber;
const int Relation::kNestedloopjoinFieldNumber;
const int Relation::kProjectFieldNumber;
const int Relation::kSampleFieldNumber;
const int Relation::kSetopFieldNumber;
const int Relation::kSortFieldNumber;
const int Relation::kSortlimitFieldNumber;
const int Relation::kEmitFieldNumber;
#endif  // !_MSC_VER

Relation::Relation()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Relation::InitAsDefaultInstance() {
  schema_ = const_cast< ::llql_proto::Schema*>(&::llql_proto::Schema::default_instance());
  distinct_ = const_cast< ::llql_proto::Distinct*>(&::llql_proto::Distinct::default_instance());
  exchange_ = const_cast< ::llql_proto::Exchange*>(&::llql_proto::Exchange::default_instance());
  extscan_ = const_cast< ::llql_proto::ExtScan*>(&::llql_proto::ExtScan::default_instance());
  filter_ = const_cast< ::llql_proto::Filter*>(&::llql_proto::Filter::default_instance());
  generator_ = const_cast< ::llql_proto::Generator*>(&::llql_proto::Generator::default_instance());
  hashagg_ = const_cast< ::llql_proto::HashAgg*>(&::llql_proto::HashAgg::default_instance());
  hashjoin_ = const_cast< ::llql_proto::HashJoin*>(&::llql_proto::HashJoin::default_instance());
  limit_ = const_cast< ::llql_proto::Limit*>(&::llql_proto::Limit::default_instance());
  nestedloopjoin_ = const_cast< ::llql_proto::NestedLoopJoin*>(&::llql_proto::NestedLoopJoin::default_instance());
  project_ = const_cast< ::llql_proto::Project*>(&::llql_proto::Project::default_instance());
  sample_ = const_cast< ::llql_proto::Sample*>(&::llql_proto::Sample::default_instance());
  setop_ = const_cast< ::llql_proto::SetOp*>(&::llql_proto::SetOp::default_instance());
  sort_ = const_cast< ::llql_proto::Sort*>(&::llql_proto::Sort::default_instance());
  sortlimit_ = const_cast< ::llql_proto::SortLimit*>(&::llql_proto::SortLimit::default_instance());
  emit_ = const_cast< ::llql_proto::Emit*>(&::llql_proto::Emit::default_instance());
}

Relation::Relation(const Relation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Relation::SharedCtor() {
  _cached_size_ = 0;
  rel_id_ = 0;
  rel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  schema_ = NULL;
  distinct_ = NULL;
  exchange_ = NULL;
  extscan_ = NULL;
  filter_ = NULL;
  generator_ = NULL;
  hashagg_ = NULL;
  hashjoin_ = NULL;
  limit_ = NULL;
  nestedloopjoin_ = NULL;
  project_ = NULL;
  sample_ = NULL;
  setop_ = NULL;
  sort_ = NULL;
  sortlimit_ = NULL;
  emit_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Relation::~Relation() {
  SharedDtor();
}

void Relation::SharedDtor() {
  if (rel_name_ != &::google::protobuf::internal::kEmptyString) {
    delete rel_name_;
  }
  if (this != default_instance_) {
    delete schema_;
    delete distinct_;
    delete exchange_;
    delete extscan_;
    delete filter_;
    delete generator_;
    delete hashagg_;
    delete hashjoin_;
    delete limit_;
    delete nestedloopjoin_;
    delete project_;
    delete sample_;
    delete setop_;
    delete sort_;
    delete sortlimit_;
    delete emit_;
  }
}

void Relation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Relation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Relation_descriptor_;
}

const Relation& Relation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Relation* Relation::default_instance_ = NULL;

Relation* Relation::New() const {
  return new Relation;
}

void Relation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rel_id_ = 0;
    if (has_rel_name()) {
      if (rel_name_ != &::google::protobuf::internal::kEmptyString) {
        rel_name_->clear();
      }
    }
    if (has_schema()) {
      if (schema_ != NULL) schema_->::llql_proto::Schema::Clear();
    }
    if (has_distinct()) {
      if (distinct_ != NULL) distinct_->::llql_proto::Distinct::Clear();
    }
    if (has_exchange()) {
      if (exchange_ != NULL) exchange_->::llql_proto::Exchange::Clear();
    }
    if (has_extscan()) {
      if (extscan_ != NULL) extscan_->::llql_proto::ExtScan::Clear();
    }
    if (has_filter()) {
      if (filter_ != NULL) filter_->::llql_proto::Filter::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_generator()) {
      if (generator_ != NULL) generator_->::llql_proto::Generator::Clear();
    }
    if (has_hashagg()) {
      if (hashagg_ != NULL) hashagg_->::llql_proto::HashAgg::Clear();
    }
    if (has_hashjoin()) {
      if (hashjoin_ != NULL) hashjoin_->::llql_proto::HashJoin::Clear();
    }
    if (has_limit()) {
      if (limit_ != NULL) limit_->::llql_proto::Limit::Clear();
    }
    if (has_nestedloopjoin()) {
      if (nestedloopjoin_ != NULL) nestedloopjoin_->::llql_proto::NestedLoopJoin::Clear();
    }
    if (has_project()) {
      if (project_ != NULL) project_->::llql_proto::Project::Clear();
    }
    if (has_sample()) {
      if (sample_ != NULL) sample_->::llql_proto::Sample::Clear();
    }
    if (has_setop()) {
      if (setop_ != NULL) setop_->::llql_proto::SetOp::Clear();
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_sort()) {
      if (sort_ != NULL) sort_->::llql_proto::Sort::Clear();
    }
    if (has_sortlimit()) {
      if (sortlimit_ != NULL) sortlimit_->::llql_proto::SortLimit::Clear();
    }
    if (has_emit()) {
      if (emit_ != NULL) emit_->::llql_proto::Emit::Clear();
    }
  }
  children_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Relation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 rel_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rel_id_)));
          set_has_rel_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_rel_name;
        break;
      }

      // optional string rel_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rel_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_rel_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->rel_name().data(), this->rel_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_schema;
        break;
      }

      // required .llql_proto.Schema schema = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_schema:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_schema()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_children;
        break;
      }

      // repeated int32 children = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_children:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32, input, this->mutable_children())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_children())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_children;
        if (input->ExpectTag(42)) goto parse_distinct;
        break;
      }

      // optional .llql_proto.Distinct distinct = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_distinct:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_distinct()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_exchange;
        break;
      }

      // optional .llql_proto.Exchange exchange = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exchange:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exchange()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_extscan;
        break;
      }

      // optional .llql_proto.ExtScan extscan = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_extscan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_extscan()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_filter;
        break;
      }

      // optional .llql_proto.Filter filter = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_generator;
        break;
      }

      // optional .llql_proto.Generator generator = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_generator:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_generator()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_hashagg;
        break;
      }

      // optional .llql_proto.HashAgg hashagg = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hashagg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hashagg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_hashjoin;
        break;
      }

      // optional .llql_proto.HashJoin hashjoin = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hashjoin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hashjoin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_limit;
        break;
      }

      // optional .llql_proto.Limit limit = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_limit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_nestedloopjoin;
        break;
      }

      // optional .llql_proto.NestedLoopJoin nestedloopjoin = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nestedloopjoin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_nestedloopjoin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_project;
        break;
      }

      // optional .llql_proto.Project project = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_project:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_project()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_sample;
        break;
      }

      // optional .llql_proto.Sample sample = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sample:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sample()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_setop;
        break;
      }

      // optional .llql_proto.SetOp setop = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_setop:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_setop()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_sort;
        break;
      }

      // optional .llql_proto.Sort sort = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sort:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sort()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_sortlimit;
        break;
      }

      // optional .llql_proto.SortLimit sortlimit = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sortlimit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sortlimit()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_emit;
        break;
      }

      // optional .llql_proto.Emit emit = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_emit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_emit()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Relation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 rel_id = 1;
  if (has_rel_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->rel_id(), output);
  }

  // optional string rel_name = 2;
  if (has_rel_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->rel_name().data(), this->rel_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->rel_name(), output);
  }

  // required .llql_proto.Schema schema = 3;
  if (has_schema()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->schema(), output);
  }

  // repeated int32 children = 4;
  for (int i = 0; i < this->children_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->children(i), output);
  }

  // optional .llql_proto.Distinct distinct = 5;
  if (has_distinct()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->distinct(), output);
  }

  // optional .llql_proto.Exchange exchange = 6;
  if (has_exchange()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->exchange(), output);
  }

  // optional .llql_proto.ExtScan extscan = 7;
  if (has_extscan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->extscan(), output);
  }

  // optional .llql_proto.Filter filter = 8;
  if (has_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->filter(), output);
  }

  // optional .llql_proto.Generator generator = 9;
  if (has_generator()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->generator(), output);
  }

  // optional .llql_proto.HashAgg hashagg = 10;
  if (has_hashagg()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->hashagg(), output);
  }

  // optional .llql_proto.HashJoin hashjoin = 11;
  if (has_hashjoin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->hashjoin(), output);
  }

  // optional .llql_proto.Limit limit = 12;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->limit(), output);
  }

  // optional .llql_proto.NestedLoopJoin nestedloopjoin = 13;
  if (has_nestedloopjoin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->nestedloopjoin(), output);
  }

  // optional .llql_proto.Project project = 14;
  if (has_project()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->project(), output);
  }

  // optional .llql_proto.Sample sample = 15;
  if (has_sample()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->sample(), output);
  }

  // optional .llql_proto.SetOp setop = 16;
  if (has_setop()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, this->setop(), output);
  }

  // optional .llql_proto.Sort sort = 17;
  if (has_sort()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, this->sort(), output);
  }

  // optional .llql_proto.SortLimit sortlimit = 18;
  if (has_sortlimit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, this->sortlimit(), output);
  }

  // optional .llql_proto.Emit emit = 19;
  if (has_emit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, this->emit(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Relation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 rel_id = 1;
  if (has_rel_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->rel_id(), target);
  }

  // optional string rel_name = 2;
  if (has_rel_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->rel_name().data(), this->rel_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->rel_name(), target);
  }

  // required .llql_proto.Schema schema = 3;
  if (has_schema()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->schema(), target);
  }

  // repeated int32 children = 4;
  for (int i = 0; i < this->children_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(4, this->children(i), target);
  }

  // optional .llql_proto.Distinct distinct = 5;
  if (has_distinct()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->distinct(), target);
  }

  // optional .llql_proto.Exchange exchange = 6;
  if (has_exchange()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->exchange(), target);
  }

  // optional .llql_proto.ExtScan extscan = 7;
  if (has_extscan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->extscan(), target);
  }

  // optional .llql_proto.Filter filter = 8;
  if (has_filter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->filter(), target);
  }

  // optional .llql_proto.Generator generator = 9;
  if (has_generator()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->generator(), target);
  }

  // optional .llql_proto.HashAgg hashagg = 10;
  if (has_hashagg()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->hashagg(), target);
  }

  // optional .llql_proto.HashJoin hashjoin = 11;
  if (has_hashjoin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->hashjoin(), target);
  }

  // optional .llql_proto.Limit limit = 12;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->limit(), target);
  }

  // optional .llql_proto.NestedLoopJoin nestedloopjoin = 13;
  if (has_nestedloopjoin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->nestedloopjoin(), target);
  }

  // optional .llql_proto.Project project = 14;
  if (has_project()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->project(), target);
  }

  // optional .llql_proto.Sample sample = 15;
  if (has_sample()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->sample(), target);
  }

  // optional .llql_proto.SetOp setop = 16;
  if (has_setop()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        16, this->setop(), target);
  }

  // optional .llql_proto.Sort sort = 17;
  if (has_sort()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        17, this->sort(), target);
  }

  // optional .llql_proto.SortLimit sortlimit = 18;
  if (has_sortlimit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        18, this->sortlimit(), target);
  }

  // optional .llql_proto.Emit emit = 19;
  if (has_emit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        19, this->emit(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Relation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 rel_id = 1;
    if (has_rel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rel_id());
    }

    // optional string rel_name = 2;
    if (has_rel_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->rel_name());
    }

    // required .llql_proto.Schema schema = 3;
    if (has_schema()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->schema());
    }

    // optional .llql_proto.Distinct distinct = 5;
    if (has_distinct()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->distinct());
    }

    // optional .llql_proto.Exchange exchange = 6;
    if (has_exchange()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exchange());
    }

    // optional .llql_proto.ExtScan extscan = 7;
    if (has_extscan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->extscan());
    }

    // optional .llql_proto.Filter filter = 8;
    if (has_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filter());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .llql_proto.Generator generator = 9;
    if (has_generator()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->generator());
    }

    // optional .llql_proto.HashAgg hashagg = 10;
    if (has_hashagg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hashagg());
    }

    // optional .llql_proto.HashJoin hashjoin = 11;
    if (has_hashjoin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hashjoin());
    }

    // optional .llql_proto.Limit limit = 12;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->limit());
    }

    // optional .llql_proto.NestedLoopJoin nestedloopjoin = 13;
    if (has_nestedloopjoin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nestedloopjoin());
    }

    // optional .llql_proto.Project project = 14;
    if (has_project()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->project());
    }

    // optional .llql_proto.Sample sample = 15;
    if (has_sample()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sample());
    }

    // optional .llql_proto.SetOp setop = 16;
    if (has_setop()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->setop());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional .llql_proto.Sort sort = 17;
    if (has_sort()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sort());
    }

    // optional .llql_proto.SortLimit sortlimit = 18;
    if (has_sortlimit()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sortlimit());
    }

    // optional .llql_proto.Emit emit = 19;
    if (has_emit()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->emit());
    }

  }
  // repeated int32 children = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->children_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->children(i));
    }
    total_size += 1 * this->children_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Relation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Relation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Relation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Relation::MergeFrom(const Relation& from) {
  GOOGLE_CHECK_NE(&from, this);
  children_.MergeFrom(from.children_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rel_id()) {
      set_rel_id(from.rel_id());
    }
    if (from.has_rel_name()) {
      set_rel_name(from.rel_name());
    }
    if (from.has_schema()) {
      mutable_schema()->::llql_proto::Schema::MergeFrom(from.schema());
    }
    if (from.has_distinct()) {
      mutable_distinct()->::llql_proto::Distinct::MergeFrom(from.distinct());
    }
    if (from.has_exchange()) {
      mutable_exchange()->::llql_proto::Exchange::MergeFrom(from.exchange());
    }
    if (from.has_extscan()) {
      mutable_extscan()->::llql_proto::ExtScan::MergeFrom(from.extscan());
    }
    if (from.has_filter()) {
      mutable_filter()->::llql_proto::Filter::MergeFrom(from.filter());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_generator()) {
      mutable_generator()->::llql_proto::Generator::MergeFrom(from.generator());
    }
    if (from.has_hashagg()) {
      mutable_hashagg()->::llql_proto::HashAgg::MergeFrom(from.hashagg());
    }
    if (from.has_hashjoin()) {
      mutable_hashjoin()->::llql_proto::HashJoin::MergeFrom(from.hashjoin());
    }
    if (from.has_limit()) {
      mutable_limit()->::llql_proto::Limit::MergeFrom(from.limit());
    }
    if (from.has_nestedloopjoin()) {
      mutable_nestedloopjoin()->::llql_proto::NestedLoopJoin::MergeFrom(from.nestedloopjoin());
    }
    if (from.has_project()) {
      mutable_project()->::llql_proto::Project::MergeFrom(from.project());
    }
    if (from.has_sample()) {
      mutable_sample()->::llql_proto::Sample::MergeFrom(from.sample());
    }
    if (from.has_setop()) {
      mutable_setop()->::llql_proto::SetOp::MergeFrom(from.setop());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_sort()) {
      mutable_sort()->::llql_proto::Sort::MergeFrom(from.sort());
    }
    if (from.has_sortlimit()) {
      mutable_sortlimit()->::llql_proto::SortLimit::MergeFrom(from.sortlimit());
    }
    if (from.has_emit()) {
      mutable_emit()->::llql_proto::Emit::MergeFrom(from.emit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Relation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Relation::CopyFrom(const Relation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Relation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  if (has_schema()) {
    if (!this->schema().IsInitialized()) return false;
  }
  if (has_distinct()) {
    if (!this->distinct().IsInitialized()) return false;
  }
  if (has_exchange()) {
    if (!this->exchange().IsInitialized()) return false;
  }
  if (has_extscan()) {
    if (!this->extscan().IsInitialized()) return false;
  }
  if (has_filter()) {
    if (!this->filter().IsInitialized()) return false;
  }
  if (has_generator()) {
    if (!this->generator().IsInitialized()) return false;
  }
  if (has_hashagg()) {
    if (!this->hashagg().IsInitialized()) return false;
  }
  if (has_hashjoin()) {
    if (!this->hashjoin().IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit().IsInitialized()) return false;
  }
  if (has_nestedloopjoin()) {
    if (!this->nestedloopjoin().IsInitialized()) return false;
  }
  if (has_project()) {
    if (!this->project().IsInitialized()) return false;
  }
  if (has_sample()) {
    if (!this->sample().IsInitialized()) return false;
  }
  if (has_setop()) {
    if (!this->setop().IsInitialized()) return false;
  }
  if (has_sort()) {
    if (!this->sort().IsInitialized()) return false;
  }
  if (has_sortlimit()) {
    if (!this->sortlimit().IsInitialized()) return false;
  }
  if (has_emit()) {
    if (!this->emit().IsInitialized()) return false;
  }
  return true;
}

void Relation::Swap(Relation* other) {
  if (other != this) {
    std::swap(rel_id_, other->rel_id_);
    std::swap(rel_name_, other->rel_name_);
    std::swap(schema_, other->schema_);
    children_.Swap(&other->children_);
    std::swap(distinct_, other->distinct_);
    std::swap(exchange_, other->exchange_);
    std::swap(extscan_, other->extscan_);
    std::swap(filter_, other->filter_);
    std::swap(generator_, other->generator_);
    std::swap(hashagg_, other->hashagg_);
    std::swap(hashjoin_, other->hashjoin_);
    std::swap(limit_, other->limit_);
    std::swap(nestedloopjoin_, other->nestedloopjoin_);
    std::swap(project_, other->project_);
    std::swap(sample_, other->sample_);
    std::swap(setop_, other->setop_);
    std::swap(sort_, other->sort_);
    std::swap(sortlimit_, other->sortlimit_);
    std::swap(emit_, other->emit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Relation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Relation_descriptor_;
  metadata.reflection = Relation_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Query::kRootFieldNumber;
const int Query::kRelsFieldNumber;
#endif  // !_MSC_VER

Query::Query()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Query::InitAsDefaultInstance() {
}

Query::Query(const Query& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Query::SharedCtor() {
  _cached_size_ = 0;
  root_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Query::~Query() {
  SharedDtor();
}

void Query::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Query::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Query::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Query_descriptor_;
}

const Query& Query::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_query_2eproto();
  return *default_instance_;
}

Query* Query::default_instance_ = NULL;

Query* Query::New() const {
  return new Query;
}

void Query::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    root_ = 0;
  }
  rels_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Query::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 root = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &root_)));
          set_has_root();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_rels;
        break;
      }

      // repeated .llql_proto.Relation rels = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rels()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_rels;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Query::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 root = 1;
  if (has_root()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->root(), output);
  }

  // repeated .llql_proto.Relation rels = 2;
  for (int i = 0; i < this->rels_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->rels(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Query::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 root = 1;
  if (has_root()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->root(), target);
  }

  // repeated .llql_proto.Relation rels = 2;
  for (int i = 0; i < this->rels_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->rels(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Query::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 root = 1;
    if (has_root()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->root());
    }

  }
  // repeated .llql_proto.Relation rels = 2;
  total_size += 1 * this->rels_size();
  for (int i = 0; i < this->rels_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rels(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Query::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Query* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Query*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Query::MergeFrom(const Query& from) {
  GOOGLE_CHECK_NE(&from, this);
  rels_.MergeFrom(from.rels_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_root()) {
      set_root(from.root());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Query::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Query::CopyFrom(const Query& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Query::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < rels_size(); i++) {
    if (!this->rels(i).IsInitialized()) return false;
  }
  return true;
}

void Query::Swap(Query* other) {
  if (other != this) {
    std::swap(root_, other->root_);
    rels_.Swap(&other->rels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Query::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Query_descriptor_;
  metadata.reflection = Query_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace llql_proto

// @@protoc_insertion_point(global_scope)
