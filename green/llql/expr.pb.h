// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: expr.proto

#ifndef PROTOBUF_expr_2eproto__INCLUDED
#define PROTOBUF_expr_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ns.pb.h"
#include "data.pb.h"
// @@protoc_insertion_point(includes)

namespace llql_proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_expr_2eproto();
void protobuf_AssignDesc_expr_2eproto();
void protobuf_ShutdownFile_expr_2eproto();

class Expr;
class Expr_Const;
class Expr_ColRef;
class Expr_Func;
class SortExpr;

enum Expr_Func_BuiltIn {
  Expr_Func_BuiltIn_FUNC_ADD = 1,
  Expr_Func_BuiltIn_FUNC_SUBTRACT = 2,
  Expr_Func_BuiltIn_FUNC_UMINUS = 3,
  Expr_Func_BuiltIn_FUNC_MULTIPLY = 4,
  Expr_Func_BuiltIn_FUNC_DIVIDE = 5,
  Expr_Func_BuiltIn_FUNC_REMAINDER = 6,
  Expr_Func_BuiltIn_FUNC_BIT_AND = 7,
  Expr_Func_BuiltIn_FUNC_BIT_OR = 8,
  Expr_Func_BuiltIn_FUNC_BIT_XOR = 9,
  Expr_Func_BuiltIn_FUNC_BIT_NOT = 10,
  Expr_Func_BuiltIn_FUNC_COMPARE = 200,
  Expr_Func_BuiltIn_FUNC_AND = 201,
  Expr_Func_BuiltIn_FUNC_OR = 202,
  Expr_Func_BuiltIn_FUNC_NOT = 203,
  Expr_Func_BuiltIn_FUNC_EQ = 204,
  Expr_Func_BuiltIn_FUNC_LT = 205,
  Expr_Func_BuiltIn_FUNC_LE = 206,
  Expr_Func_BuiltIn_FUNC_GT = 207,
  Expr_Func_BuiltIn_FUNC_GE = 208,
  Expr_Func_BuiltIn_FUNC_NE = 209,
  Expr_Func_BuiltIn_FUNC_REGEXP_MATCH = 300,
  Expr_Func_BuiltIn_FUNC_LIKE = 301,
  Expr_Func_BuiltIn_FUNC_LOWER = 302,
  Expr_Func_BuiltIn_FUNC_UPPER = 303,
  Expr_Func_BuiltIn_FUNC_STR_COMPARE = 304,
  Expr_Func_BuiltIn_FUNC_STR_CONTAINS = 305,
  Expr_Func_BuiltIn_FUNC_START_WITH = 306,
  Expr_Func_BuiltIn_FUNC_END_WITH = 307,
  Expr_Func_BuiltIn_FUNC_SUBSTRING = 308,
  Expr_Func_BuiltIn_FUNC_ABS = 400,
  Expr_Func_BuiltIn_FUNC_SQRT = 401,
  Expr_Func_BuiltIn_FUNC_CAST = 500,
  Expr_Func_BuiltIn_FUNC_COALESCE = 501,
  Expr_Func_BuiltIn_FUNC_ISNULL = 502,
  Expr_Func_BuiltIn_FUNC_ISNOTNULL = 503,
  Expr_Func_BuiltIn_FUNC_MIN = 504,
  Expr_Func_BuiltIn_FUNC_MAX = 505,
  Expr_Func_BuiltIn_FUNC_IN = 506,
  Expr_Func_BuiltIn_FUNC_IF = 507,
  Expr_Func_BuiltIn_FUNC_CASE = 508,
  Expr_Func_BuiltIn_FUNC_EMPTY_ARRAY = 90000,
  Expr_Func_BuiltIn_FUNC_ARRAY_INDEX = 90001,
  Expr_Func_BuiltIn_FUNC_EMPTY_SET = 90100,
  Expr_Func_BuiltIn_FUNC_ADD_TO_SET = 90101,
  Expr_Func_BuiltIn_FUNC_UNION = 90102,
  Expr_Func_BuiltIn_FUNC_COUNT = 90103,
  Expr_Func_BuiltIn_FUNC_GEN_EXPRS = 99900,
  Expr_Func_BuiltIn_FUNC_GEN_UNNEST = 99901,
  Expr_Func_BuiltIn_AGG_COUNT = 1000001,
  Expr_Func_BuiltIn_AGG_SUM = 1000002,
  Expr_Func_BuiltIn_AGG_MIN = 1000003,
  Expr_Func_BuiltIn_AGG_MAX = 1000004,
  Expr_Func_BuiltIn_AGG_AVG = 1000005,
  Expr_Func_BuiltIn_AGG_FIRST = 1000006,
  Expr_Func_BuiltIn_AGG_LAST = 1000007,
  Expr_Func_BuiltIn_AGG_APPROXIMATE_COUNT = 1090001,
  Expr_Func_BuiltIn_AGG_COLLECT_SET = 1099901,
  Expr_Func_BuiltIn_AGG_UNION = 1099902,
  Expr_Func_BuiltIn_AGG_UNION_AND_COUNT = 1099903
};
bool Expr_Func_BuiltIn_IsValid(int value);
const Expr_Func_BuiltIn Expr_Func_BuiltIn_BuiltIn_MIN = Expr_Func_BuiltIn_FUNC_ADD;
const Expr_Func_BuiltIn Expr_Func_BuiltIn_BuiltIn_MAX = Expr_Func_BuiltIn_AGG_UNION_AND_COUNT;
const int Expr_Func_BuiltIn_BuiltIn_ARRAYSIZE = Expr_Func_BuiltIn_BuiltIn_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expr_Func_BuiltIn_descriptor();
inline const ::std::string& Expr_Func_BuiltIn_Name(Expr_Func_BuiltIn value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expr_Func_BuiltIn_descriptor(), value);
}
inline bool Expr_Func_BuiltIn_Parse(
    const ::std::string& name, Expr_Func_BuiltIn* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expr_Func_BuiltIn>(
    Expr_Func_BuiltIn_descriptor(), name, value);
}
// ===================================================================

class Expr_Const : public ::google::protobuf::Message {
 public:
  Expr_Const();
  virtual ~Expr_Const();

  Expr_Const(const Expr_Const& from);

  inline Expr_Const& operator=(const Expr_Const& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr_Const& default_instance();

  void Swap(Expr_Const* other);

  // implements Message ----------------------------------------------

  Expr_Const* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expr_Const& from);
  void MergeFrom(const Expr_Const& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_null = 1;
  inline bool has_is_null() const;
  inline void clear_is_null();
  static const int kIsNullFieldNumber = 1;
  inline bool is_null() const;
  inline void set_is_null(bool value);

  // required string str_val = 2;
  inline bool has_str_val() const;
  inline void clear_str_val();
  static const int kStrValFieldNumber = 2;
  inline const ::std::string& str_val() const;
  inline void set_str_val(const ::std::string& value);
  inline void set_str_val(const char* value);
  inline void set_str_val(const char* value, size_t size);
  inline ::std::string* mutable_str_val();
  inline ::std::string* release_str_val();
  inline void set_allocated_str_val(::std::string* str_val);

  // @@protoc_insertion_point(class_scope:llql_proto.Expr.Const)
 private:
  inline void set_has_is_null();
  inline void clear_has_is_null();
  inline void set_has_str_val();
  inline void clear_has_str_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_val_;
  bool is_null_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Expr_Const* default_instance_;
};
// -------------------------------------------------------------------

class Expr_ColRef : public ::google::protobuf::Message {
 public:
  Expr_ColRef();
  virtual ~Expr_ColRef();

  Expr_ColRef(const Expr_ColRef& from);

  inline Expr_ColRef& operator=(const Expr_ColRef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr_ColRef& default_instance();

  void Swap(Expr_ColRef* other);

  // implements Message ----------------------------------------------

  Expr_ColRef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expr_ColRef& from);
  void MergeFrom(const Expr_ColRef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rel_id = 1;
  inline bool has_rel_id() const;
  inline void clear_rel_id();
  static const int kRelIdFieldNumber = 1;
  inline ::google::protobuf::int32 rel_id() const;
  inline void set_rel_id(::google::protobuf::int32 value);

  // required int32 col_id = 2;
  inline bool has_col_id() const;
  inline void clear_col_id();
  static const int kColIdFieldNumber = 2;
  inline ::google::protobuf::int32 col_id() const;
  inline void set_col_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:llql_proto.Expr.ColRef)
 private:
  inline void set_has_rel_id();
  inline void clear_has_rel_id();
  inline void set_has_col_id();
  inline void clear_has_col_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rel_id_;
  ::google::protobuf::int32 col_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Expr_ColRef* default_instance_;
};
// -------------------------------------------------------------------

class Expr_Func : public ::google::protobuf::Message {
 public:
  Expr_Func();
  virtual ~Expr_Func();

  Expr_Func(const Expr_Func& from);

  inline Expr_Func& operator=(const Expr_Func& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr_Func& default_instance();

  void Swap(Expr_Func* other);

  // implements Message ----------------------------------------------

  Expr_Func* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expr_Func& from);
  void MergeFrom(const Expr_Func& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Expr_Func_BuiltIn BuiltIn;
  static const BuiltIn FUNC_ADD = Expr_Func_BuiltIn_FUNC_ADD;
  static const BuiltIn FUNC_SUBTRACT = Expr_Func_BuiltIn_FUNC_SUBTRACT;
  static const BuiltIn FUNC_UMINUS = Expr_Func_BuiltIn_FUNC_UMINUS;
  static const BuiltIn FUNC_MULTIPLY = Expr_Func_BuiltIn_FUNC_MULTIPLY;
  static const BuiltIn FUNC_DIVIDE = Expr_Func_BuiltIn_FUNC_DIVIDE;
  static const BuiltIn FUNC_REMAINDER = Expr_Func_BuiltIn_FUNC_REMAINDER;
  static const BuiltIn FUNC_BIT_AND = Expr_Func_BuiltIn_FUNC_BIT_AND;
  static const BuiltIn FUNC_BIT_OR = Expr_Func_BuiltIn_FUNC_BIT_OR;
  static const BuiltIn FUNC_BIT_XOR = Expr_Func_BuiltIn_FUNC_BIT_XOR;
  static const BuiltIn FUNC_BIT_NOT = Expr_Func_BuiltIn_FUNC_BIT_NOT;
  static const BuiltIn FUNC_COMPARE = Expr_Func_BuiltIn_FUNC_COMPARE;
  static const BuiltIn FUNC_AND = Expr_Func_BuiltIn_FUNC_AND;
  static const BuiltIn FUNC_OR = Expr_Func_BuiltIn_FUNC_OR;
  static const BuiltIn FUNC_NOT = Expr_Func_BuiltIn_FUNC_NOT;
  static const BuiltIn FUNC_EQ = Expr_Func_BuiltIn_FUNC_EQ;
  static const BuiltIn FUNC_LT = Expr_Func_BuiltIn_FUNC_LT;
  static const BuiltIn FUNC_LE = Expr_Func_BuiltIn_FUNC_LE;
  static const BuiltIn FUNC_GT = Expr_Func_BuiltIn_FUNC_GT;
  static const BuiltIn FUNC_GE = Expr_Func_BuiltIn_FUNC_GE;
  static const BuiltIn FUNC_NE = Expr_Func_BuiltIn_FUNC_NE;
  static const BuiltIn FUNC_REGEXP_MATCH = Expr_Func_BuiltIn_FUNC_REGEXP_MATCH;
  static const BuiltIn FUNC_LIKE = Expr_Func_BuiltIn_FUNC_LIKE;
  static const BuiltIn FUNC_LOWER = Expr_Func_BuiltIn_FUNC_LOWER;
  static const BuiltIn FUNC_UPPER = Expr_Func_BuiltIn_FUNC_UPPER;
  static const BuiltIn FUNC_STR_COMPARE = Expr_Func_BuiltIn_FUNC_STR_COMPARE;
  static const BuiltIn FUNC_STR_CONTAINS = Expr_Func_BuiltIn_FUNC_STR_CONTAINS;
  static const BuiltIn FUNC_START_WITH = Expr_Func_BuiltIn_FUNC_START_WITH;
  static const BuiltIn FUNC_END_WITH = Expr_Func_BuiltIn_FUNC_END_WITH;
  static const BuiltIn FUNC_SUBSTRING = Expr_Func_BuiltIn_FUNC_SUBSTRING;
  static const BuiltIn FUNC_ABS = Expr_Func_BuiltIn_FUNC_ABS;
  static const BuiltIn FUNC_SQRT = Expr_Func_BuiltIn_FUNC_SQRT;
  static const BuiltIn FUNC_CAST = Expr_Func_BuiltIn_FUNC_CAST;
  static const BuiltIn FUNC_COALESCE = Expr_Func_BuiltIn_FUNC_COALESCE;
  static const BuiltIn FUNC_ISNULL = Expr_Func_BuiltIn_FUNC_ISNULL;
  static const BuiltIn FUNC_ISNOTNULL = Expr_Func_BuiltIn_FUNC_ISNOTNULL;
  static const BuiltIn FUNC_MIN = Expr_Func_BuiltIn_FUNC_MIN;
  static const BuiltIn FUNC_MAX = Expr_Func_BuiltIn_FUNC_MAX;
  static const BuiltIn FUNC_IN = Expr_Func_BuiltIn_FUNC_IN;
  static const BuiltIn FUNC_IF = Expr_Func_BuiltIn_FUNC_IF;
  static const BuiltIn FUNC_CASE = Expr_Func_BuiltIn_FUNC_CASE;
  static const BuiltIn FUNC_EMPTY_ARRAY = Expr_Func_BuiltIn_FUNC_EMPTY_ARRAY;
  static const BuiltIn FUNC_ARRAY_INDEX = Expr_Func_BuiltIn_FUNC_ARRAY_INDEX;
  static const BuiltIn FUNC_EMPTY_SET = Expr_Func_BuiltIn_FUNC_EMPTY_SET;
  static const BuiltIn FUNC_ADD_TO_SET = Expr_Func_BuiltIn_FUNC_ADD_TO_SET;
  static const BuiltIn FUNC_UNION = Expr_Func_BuiltIn_FUNC_UNION;
  static const BuiltIn FUNC_COUNT = Expr_Func_BuiltIn_FUNC_COUNT;
  static const BuiltIn FUNC_GEN_EXPRS = Expr_Func_BuiltIn_FUNC_GEN_EXPRS;
  static const BuiltIn FUNC_GEN_UNNEST = Expr_Func_BuiltIn_FUNC_GEN_UNNEST;
  static const BuiltIn AGG_COUNT = Expr_Func_BuiltIn_AGG_COUNT;
  static const BuiltIn AGG_SUM = Expr_Func_BuiltIn_AGG_SUM;
  static const BuiltIn AGG_MIN = Expr_Func_BuiltIn_AGG_MIN;
  static const BuiltIn AGG_MAX = Expr_Func_BuiltIn_AGG_MAX;
  static const BuiltIn AGG_AVG = Expr_Func_BuiltIn_AGG_AVG;
  static const BuiltIn AGG_FIRST = Expr_Func_BuiltIn_AGG_FIRST;
  static const BuiltIn AGG_LAST = Expr_Func_BuiltIn_AGG_LAST;
  static const BuiltIn AGG_APPROXIMATE_COUNT = Expr_Func_BuiltIn_AGG_APPROXIMATE_COUNT;
  static const BuiltIn AGG_COLLECT_SET = Expr_Func_BuiltIn_AGG_COLLECT_SET;
  static const BuiltIn AGG_UNION = Expr_Func_BuiltIn_AGG_UNION;
  static const BuiltIn AGG_UNION_AND_COUNT = Expr_Func_BuiltIn_AGG_UNION_AND_COUNT;
  static inline bool BuiltIn_IsValid(int value) {
    return Expr_Func_BuiltIn_IsValid(value);
  }
  static const BuiltIn BuiltIn_MIN =
    Expr_Func_BuiltIn_BuiltIn_MIN;
  static const BuiltIn BuiltIn_MAX =
    Expr_Func_BuiltIn_BuiltIn_MAX;
  static const int BuiltIn_ARRAYSIZE =
    Expr_Func_BuiltIn_BuiltIn_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BuiltIn_descriptor() {
    return Expr_Func_BuiltIn_descriptor();
  }
  static inline const ::std::string& BuiltIn_Name(BuiltIn value) {
    return Expr_Func_BuiltIn_Name(value);
  }
  static inline bool BuiltIn_Parse(const ::std::string& name,
      BuiltIn* value) {
    return Expr_Func_BuiltIn_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .llql_proto.Namespace ns = 1;
  inline bool has_ns() const;
  inline void clear_ns();
  static const int kNsFieldNumber = 1;
  inline ::llql_proto::Namespace ns() const;
  inline void set_ns(::llql_proto::Namespace value);

  // required int32 func_id = 2;
  inline bool has_func_id() const;
  inline void clear_func_id();
  static const int kFuncIdFieldNumber = 2;
  inline ::google::protobuf::int32 func_id() const;
  inline void set_func_id(::google::protobuf::int32 value);

  // required bool is_volatile = 3 [default = false];
  inline bool has_is_volatile() const;
  inline void clear_is_volatile();
  static const int kIsVolatileFieldNumber = 3;
  inline bool is_volatile() const;
  inline void set_is_volatile(bool value);

  // required bool is_strict = 4 [default = true];
  inline bool has_is_strict() const;
  inline void clear_is_strict();
  static const int kIsStrictFieldNumber = 4;
  inline bool is_strict() const;
  inline void set_is_strict(bool value);

  // required bool is_distinct = 5 [default = false];
  inline bool has_is_distinct() const;
  inline void clear_is_distinct();
  static const int kIsDistinctFieldNumber = 5;
  inline bool is_distinct() const;
  inline void set_is_distinct(bool value);

  // repeated .llql_proto.Expr args = 6;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 6;
  inline const ::llql_proto::Expr& args(int index) const;
  inline ::llql_proto::Expr* mutable_args(int index);
  inline ::llql_proto::Expr* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
      mutable_args();

  // @@protoc_insertion_point(class_scope:llql_proto.Expr.Func)
 private:
  inline void set_has_ns();
  inline void clear_has_ns();
  inline void set_has_func_id();
  inline void clear_has_func_id();
  inline void set_has_is_volatile();
  inline void clear_has_is_volatile();
  inline void set_has_is_strict();
  inline void clear_has_is_strict();
  inline void set_has_is_distinct();
  inline void clear_has_is_distinct();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ns_;
  ::google::protobuf::int32 func_id_;
  ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr > args_;
  bool is_volatile_;
  bool is_strict_;
  bool is_distinct_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Expr_Func* default_instance_;
};
// -------------------------------------------------------------------

class Expr : public ::google::protobuf::Message {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr& default_instance();

  void Swap(Expr* other);

  // implements Message ----------------------------------------------

  Expr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Expr_Const Const;
  typedef Expr_ColRef ColRef;
  typedef Expr_Func Func;

  // accessors -------------------------------------------------------

  // required .llql_proto.DataType dt = 1;
  inline bool has_dt() const;
  inline void clear_dt();
  static const int kDtFieldNumber = 1;
  inline const ::llql_proto::DataType& dt() const;
  inline ::llql_proto::DataType* mutable_dt();
  inline ::llql_proto::DataType* release_dt();
  inline void set_allocated_dt(::llql_proto::DataType* dt);

  // optional .llql_proto.Expr.Const const_val = 2;
  inline bool has_const_val() const;
  inline void clear_const_val();
  static const int kConstValFieldNumber = 2;
  inline const ::llql_proto::Expr_Const& const_val() const;
  inline ::llql_proto::Expr_Const* mutable_const_val();
  inline ::llql_proto::Expr_Const* release_const_val();
  inline void set_allocated_const_val(::llql_proto::Expr_Const* const_val);

  // optional .llql_proto.Expr.ColRef colref = 3;
  inline bool has_colref() const;
  inline void clear_colref();
  static const int kColrefFieldNumber = 3;
  inline const ::llql_proto::Expr_ColRef& colref() const;
  inline ::llql_proto::Expr_ColRef* mutable_colref();
  inline ::llql_proto::Expr_ColRef* release_colref();
  inline void set_allocated_colref(::llql_proto::Expr_ColRef* colref);

  // optional .llql_proto.Expr.Func func = 4;
  inline bool has_func() const;
  inline void clear_func();
  static const int kFuncFieldNumber = 4;
  inline const ::llql_proto::Expr_Func& func() const;
  inline ::llql_proto::Expr_Func* mutable_func();
  inline ::llql_proto::Expr_Func* release_func();
  inline void set_allocated_func(::llql_proto::Expr_Func* func);

  // @@protoc_insertion_point(class_scope:llql_proto.Expr)
 private:
  inline void set_has_dt();
  inline void clear_has_dt();
  inline void set_has_const_val();
  inline void clear_has_const_val();
  inline void set_has_colref();
  inline void clear_has_colref();
  inline void set_has_func();
  inline void clear_has_func();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::llql_proto::DataType* dt_;
  ::llql_proto::Expr_Const* const_val_;
  ::llql_proto::Expr_ColRef* colref_;
  ::llql_proto::Expr_Func* func_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Expr* default_instance_;
};
// -------------------------------------------------------------------

class SortExpr : public ::google::protobuf::Message {
 public:
  SortExpr();
  virtual ~SortExpr();

  SortExpr(const SortExpr& from);

  inline SortExpr& operator=(const SortExpr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SortExpr& default_instance();

  void Swap(SortExpr* other);

  // implements Message ----------------------------------------------

  SortExpr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SortExpr& from);
  void MergeFrom(const SortExpr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .llql_proto.Expr expr = 1;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 1;
  inline const ::llql_proto::Expr& expr() const;
  inline ::llql_proto::Expr* mutable_expr();
  inline ::llql_proto::Expr* release_expr();
  inline void set_allocated_expr(::llql_proto::Expr* expr);

  // required bool desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline bool desc() const;
  inline void set_desc(bool value);

  // required bool null_first = 3;
  inline bool has_null_first() const;
  inline void clear_null_first();
  static const int kNullFirstFieldNumber = 3;
  inline bool null_first() const;
  inline void set_null_first(bool value);

  // @@protoc_insertion_point(class_scope:llql_proto.SortExpr)
 private:
  inline void set_has_expr();
  inline void clear_has_expr();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_null_first();
  inline void clear_has_null_first();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::llql_proto::Expr* expr_;
  bool desc_;
  bool null_first_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static SortExpr* default_instance_;
};
// ===================================================================


// ===================================================================

// Expr_Const

// required bool is_null = 1;
inline bool Expr_Const::has_is_null() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expr_Const::set_has_is_null() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expr_Const::clear_has_is_null() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expr_Const::clear_is_null() {
  is_null_ = false;
  clear_has_is_null();
}
inline bool Expr_Const::is_null() const {
  return is_null_;
}
inline void Expr_Const::set_is_null(bool value) {
  set_has_is_null();
  is_null_ = value;
}

// required string str_val = 2;
inline bool Expr_Const::has_str_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expr_Const::set_has_str_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expr_Const::clear_has_str_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expr_Const::clear_str_val() {
  if (str_val_ != &::google::protobuf::internal::kEmptyString) {
    str_val_->clear();
  }
  clear_has_str_val();
}
inline const ::std::string& Expr_Const::str_val() const {
  return *str_val_;
}
inline void Expr_Const::set_str_val(const ::std::string& value) {
  set_has_str_val();
  if (str_val_ == &::google::protobuf::internal::kEmptyString) {
    str_val_ = new ::std::string;
  }
  str_val_->assign(value);
}
inline void Expr_Const::set_str_val(const char* value) {
  set_has_str_val();
  if (str_val_ == &::google::protobuf::internal::kEmptyString) {
    str_val_ = new ::std::string;
  }
  str_val_->assign(value);
}
inline void Expr_Const::set_str_val(const char* value, size_t size) {
  set_has_str_val();
  if (str_val_ == &::google::protobuf::internal::kEmptyString) {
    str_val_ = new ::std::string;
  }
  str_val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Expr_Const::mutable_str_val() {
  set_has_str_val();
  if (str_val_ == &::google::protobuf::internal::kEmptyString) {
    str_val_ = new ::std::string;
  }
  return str_val_;
}
inline ::std::string* Expr_Const::release_str_val() {
  clear_has_str_val();
  if (str_val_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_val_;
    str_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Expr_Const::set_allocated_str_val(::std::string* str_val) {
  if (str_val_ != &::google::protobuf::internal::kEmptyString) {
    delete str_val_;
  }
  if (str_val) {
    set_has_str_val();
    str_val_ = str_val;
  } else {
    clear_has_str_val();
    str_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Expr_ColRef

// required int32 rel_id = 1;
inline bool Expr_ColRef::has_rel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expr_ColRef::set_has_rel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expr_ColRef::clear_has_rel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expr_ColRef::clear_rel_id() {
  rel_id_ = 0;
  clear_has_rel_id();
}
inline ::google::protobuf::int32 Expr_ColRef::rel_id() const {
  return rel_id_;
}
inline void Expr_ColRef::set_rel_id(::google::protobuf::int32 value) {
  set_has_rel_id();
  rel_id_ = value;
}

// required int32 col_id = 2;
inline bool Expr_ColRef::has_col_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expr_ColRef::set_has_col_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expr_ColRef::clear_has_col_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expr_ColRef::clear_col_id() {
  col_id_ = 0;
  clear_has_col_id();
}
inline ::google::protobuf::int32 Expr_ColRef::col_id() const {
  return col_id_;
}
inline void Expr_ColRef::set_col_id(::google::protobuf::int32 value) {
  set_has_col_id();
  col_id_ = value;
}

// -------------------------------------------------------------------

// Expr_Func

// required .llql_proto.Namespace ns = 1;
inline bool Expr_Func::has_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expr_Func::set_has_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expr_Func::clear_has_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expr_Func::clear_ns() {
  ns_ = 0;
  clear_has_ns();
}
inline ::llql_proto::Namespace Expr_Func::ns() const {
  return static_cast< ::llql_proto::Namespace >(ns_);
}
inline void Expr_Func::set_ns(::llql_proto::Namespace value) {
  assert(::llql_proto::Namespace_IsValid(value));
  set_has_ns();
  ns_ = value;
}

// required int32 func_id = 2;
inline bool Expr_Func::has_func_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expr_Func::set_has_func_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expr_Func::clear_has_func_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expr_Func::clear_func_id() {
  func_id_ = 0;
  clear_has_func_id();
}
inline ::google::protobuf::int32 Expr_Func::func_id() const {
  return func_id_;
}
inline void Expr_Func::set_func_id(::google::protobuf::int32 value) {
  set_has_func_id();
  func_id_ = value;
}

// required bool is_volatile = 3 [default = false];
inline bool Expr_Func::has_is_volatile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Expr_Func::set_has_is_volatile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Expr_Func::clear_has_is_volatile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Expr_Func::clear_is_volatile() {
  is_volatile_ = false;
  clear_has_is_volatile();
}
inline bool Expr_Func::is_volatile() const {
  return is_volatile_;
}
inline void Expr_Func::set_is_volatile(bool value) {
  set_has_is_volatile();
  is_volatile_ = value;
}

// required bool is_strict = 4 [default = true];
inline bool Expr_Func::has_is_strict() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Expr_Func::set_has_is_strict() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Expr_Func::clear_has_is_strict() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Expr_Func::clear_is_strict() {
  is_strict_ = true;
  clear_has_is_strict();
}
inline bool Expr_Func::is_strict() const {
  return is_strict_;
}
inline void Expr_Func::set_is_strict(bool value) {
  set_has_is_strict();
  is_strict_ = value;
}

// required bool is_distinct = 5 [default = false];
inline bool Expr_Func::has_is_distinct() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Expr_Func::set_has_is_distinct() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Expr_Func::clear_has_is_distinct() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Expr_Func::clear_is_distinct() {
  is_distinct_ = false;
  clear_has_is_distinct();
}
inline bool Expr_Func::is_distinct() const {
  return is_distinct_;
}
inline void Expr_Func::set_is_distinct(bool value) {
  set_has_is_distinct();
  is_distinct_ = value;
}

// repeated .llql_proto.Expr args = 6;
inline int Expr_Func::args_size() const {
  return args_.size();
}
inline void Expr_Func::clear_args() {
  args_.Clear();
}
inline const ::llql_proto::Expr& Expr_Func::args(int index) const {
  return args_.Get(index);
}
inline ::llql_proto::Expr* Expr_Func::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::llql_proto::Expr* Expr_Func::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
Expr_Func::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
Expr_Func::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// Expr

// required .llql_proto.DataType dt = 1;
inline bool Expr::has_dt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expr::set_has_dt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expr::clear_has_dt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expr::clear_dt() {
  if (dt_ != NULL) dt_->::llql_proto::DataType::Clear();
  clear_has_dt();
}
inline const ::llql_proto::DataType& Expr::dt() const {
  return dt_ != NULL ? *dt_ : *default_instance_->dt_;
}
inline ::llql_proto::DataType* Expr::mutable_dt() {
  set_has_dt();
  if (dt_ == NULL) dt_ = new ::llql_proto::DataType;
  return dt_;
}
inline ::llql_proto::DataType* Expr::release_dt() {
  clear_has_dt();
  ::llql_proto::DataType* temp = dt_;
  dt_ = NULL;
  return temp;
}
inline void Expr::set_allocated_dt(::llql_proto::DataType* dt) {
  delete dt_;
  dt_ = dt;
  if (dt) {
    set_has_dt();
  } else {
    clear_has_dt();
  }
}

// optional .llql_proto.Expr.Const const_val = 2;
inline bool Expr::has_const_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expr::set_has_const_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expr::clear_has_const_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expr::clear_const_val() {
  if (const_val_ != NULL) const_val_->::llql_proto::Expr_Const::Clear();
  clear_has_const_val();
}
inline const ::llql_proto::Expr_Const& Expr::const_val() const {
  return const_val_ != NULL ? *const_val_ : *default_instance_->const_val_;
}
inline ::llql_proto::Expr_Const* Expr::mutable_const_val() {
  set_has_const_val();
  if (const_val_ == NULL) const_val_ = new ::llql_proto::Expr_Const;
  return const_val_;
}
inline ::llql_proto::Expr_Const* Expr::release_const_val() {
  clear_has_const_val();
  ::llql_proto::Expr_Const* temp = const_val_;
  const_val_ = NULL;
  return temp;
}
inline void Expr::set_allocated_const_val(::llql_proto::Expr_Const* const_val) {
  delete const_val_;
  const_val_ = const_val;
  if (const_val) {
    set_has_const_val();
  } else {
    clear_has_const_val();
  }
}

// optional .llql_proto.Expr.ColRef colref = 3;
inline bool Expr::has_colref() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Expr::set_has_colref() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Expr::clear_has_colref() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Expr::clear_colref() {
  if (colref_ != NULL) colref_->::llql_proto::Expr_ColRef::Clear();
  clear_has_colref();
}
inline const ::llql_proto::Expr_ColRef& Expr::colref() const {
  return colref_ != NULL ? *colref_ : *default_instance_->colref_;
}
inline ::llql_proto::Expr_ColRef* Expr::mutable_colref() {
  set_has_colref();
  if (colref_ == NULL) colref_ = new ::llql_proto::Expr_ColRef;
  return colref_;
}
inline ::llql_proto::Expr_ColRef* Expr::release_colref() {
  clear_has_colref();
  ::llql_proto::Expr_ColRef* temp = colref_;
  colref_ = NULL;
  return temp;
}
inline void Expr::set_allocated_colref(::llql_proto::Expr_ColRef* colref) {
  delete colref_;
  colref_ = colref;
  if (colref) {
    set_has_colref();
  } else {
    clear_has_colref();
  }
}

// optional .llql_proto.Expr.Func func = 4;
inline bool Expr::has_func() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Expr::set_has_func() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Expr::clear_has_func() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Expr::clear_func() {
  if (func_ != NULL) func_->::llql_proto::Expr_Func::Clear();
  clear_has_func();
}
inline const ::llql_proto::Expr_Func& Expr::func() const {
  return func_ != NULL ? *func_ : *default_instance_->func_;
}
inline ::llql_proto::Expr_Func* Expr::mutable_func() {
  set_has_func();
  if (func_ == NULL) func_ = new ::llql_proto::Expr_Func;
  return func_;
}
inline ::llql_proto::Expr_Func* Expr::release_func() {
  clear_has_func();
  ::llql_proto::Expr_Func* temp = func_;
  func_ = NULL;
  return temp;
}
inline void Expr::set_allocated_func(::llql_proto::Expr_Func* func) {
  delete func_;
  func_ = func;
  if (func) {
    set_has_func();
  } else {
    clear_has_func();
  }
}

// -------------------------------------------------------------------

// SortExpr

// required .llql_proto.Expr expr = 1;
inline bool SortExpr::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SortExpr::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SortExpr::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SortExpr::clear_expr() {
  if (expr_ != NULL) expr_->::llql_proto::Expr::Clear();
  clear_has_expr();
}
inline const ::llql_proto::Expr& SortExpr::expr() const {
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
}
inline ::llql_proto::Expr* SortExpr::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::llql_proto::Expr;
  return expr_;
}
inline ::llql_proto::Expr* SortExpr::release_expr() {
  clear_has_expr();
  ::llql_proto::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void SortExpr::set_allocated_expr(::llql_proto::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
}

// required bool desc = 2;
inline bool SortExpr::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SortExpr::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SortExpr::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SortExpr::clear_desc() {
  desc_ = false;
  clear_has_desc();
}
inline bool SortExpr::desc() const {
  return desc_;
}
inline void SortExpr::set_desc(bool value) {
  set_has_desc();
  desc_ = value;
}

// required bool null_first = 3;
inline bool SortExpr::has_null_first() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SortExpr::set_has_null_first() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SortExpr::clear_has_null_first() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SortExpr::clear_null_first() {
  null_first_ = false;
  clear_has_null_first();
}
inline bool SortExpr::null_first() const {
  return null_first_;
}
inline void SortExpr::set_null_first(bool value) {
  set_has_null_first();
  null_first_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace llql_proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llql_proto::Expr_Func_BuiltIn>() {
  return ::llql_proto::Expr_Func_BuiltIn_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_expr_2eproto__INCLUDED
