// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: query.proto

#ifndef PROTOBUF_query_2eproto__INCLUDED
#define PROTOBUF_query_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "data.pb.h"
#include "expr.pb.h"
// @@protoc_insertion_point(includes)

namespace llql_proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_query_2eproto();
void protobuf_AssignDesc_query_2eproto();
void protobuf_ShutdownFile_query_2eproto();

class Distinct;
class Exchange;
class ExtScan;
class Filter;
class Generator;
class HashAgg;
class HashJoin;
class Limit;
class NestedLoopJoin;
class Project;
class Sample;
class SetOp;
class Sort;
class SortLimit;
class Emit;
class Relation;
class Query;

enum Exchange_ExchangeType {
  Exchange_ExchangeType_BROADCAST = 0,
  Exchange_ExchangeType_HASH = 1,
  Exchange_ExchangeType_RANGE = 2
};
bool Exchange_ExchangeType_IsValid(int value);
const Exchange_ExchangeType Exchange_ExchangeType_ExchangeType_MIN = Exchange_ExchangeType_BROADCAST;
const Exchange_ExchangeType Exchange_ExchangeType_ExchangeType_MAX = Exchange_ExchangeType_RANGE;
const int Exchange_ExchangeType_ExchangeType_ARRAYSIZE = Exchange_ExchangeType_ExchangeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Exchange_ExchangeType_descriptor();
inline const ::std::string& Exchange_ExchangeType_Name(Exchange_ExchangeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Exchange_ExchangeType_descriptor(), value);
}
inline bool Exchange_ExchangeType_Parse(
    const ::std::string& name, Exchange_ExchangeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Exchange_ExchangeType>(
    Exchange_ExchangeType_descriptor(), name, value);
}
enum ExtScan_DSType {
  ExtScan_DSType_CSV = 0,
  ExtScan_DSType_PG_TEXT = 1,
  ExtScan_DSType_PARQUET = 2
};
bool ExtScan_DSType_IsValid(int value);
const ExtScan_DSType ExtScan_DSType_DSType_MIN = ExtScan_DSType_CSV;
const ExtScan_DSType ExtScan_DSType_DSType_MAX = ExtScan_DSType_PARQUET;
const int ExtScan_DSType_DSType_ARRAYSIZE = ExtScan_DSType_DSType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExtScan_DSType_descriptor();
inline const ::std::string& ExtScan_DSType_Name(ExtScan_DSType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExtScan_DSType_descriptor(), value);
}
inline bool ExtScan_DSType_Parse(
    const ::std::string& name, ExtScan_DSType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExtScan_DSType>(
    ExtScan_DSType_descriptor(), name, value);
}
enum SetOp_SetOpType {
  SetOp_SetOpType_UNION = 0,
  SetOp_SetOpType_UNION_ALL = 1,
  SetOp_SetOpType_INTERSECT = 2,
  SetOp_SetOpType_EXCEPT = 3
};
bool SetOp_SetOpType_IsValid(int value);
const SetOp_SetOpType SetOp_SetOpType_SetOpType_MIN = SetOp_SetOpType_UNION;
const SetOp_SetOpType SetOp_SetOpType_SetOpType_MAX = SetOp_SetOpType_EXCEPT;
const int SetOp_SetOpType_SetOpType_ARRAYSIZE = SetOp_SetOpType_SetOpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SetOp_SetOpType_descriptor();
inline const ::std::string& SetOp_SetOpType_Name(SetOp_SetOpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SetOp_SetOpType_descriptor(), value);
}
inline bool SetOp_SetOpType_Parse(
    const ::std::string& name, SetOp_SetOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SetOp_SetOpType>(
    SetOp_SetOpType_descriptor(), name, value);
}
enum JoinType {
  INNER = 0,
  LEFT_OUTER = 1,
  RIGHT_OUTER = 2,
  FULL_OUTER = 3,
  LEFT_SEMI = 4
};
bool JoinType_IsValid(int value);
const JoinType JoinType_MIN = INNER;
const JoinType JoinType_MAX = LEFT_SEMI;
const int JoinType_ARRAYSIZE = JoinType_MAX + 1;

const ::google::protobuf::EnumDescriptor* JoinType_descriptor();
inline const ::std::string& JoinType_Name(JoinType value) {
  return ::google::protobuf::internal::NameOfEnum(
    JoinType_descriptor(), value);
}
inline bool JoinType_Parse(
    const ::std::string& name, JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JoinType>(
    JoinType_descriptor(), name, value);
}
// ===================================================================

class Distinct : public ::google::protobuf::Message {
 public:
  Distinct();
  virtual ~Distinct();

  Distinct(const Distinct& from);

  inline Distinct& operator=(const Distinct& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Distinct& default_instance();

  void Swap(Distinct* other);

  // implements Message ----------------------------------------------

  Distinct* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Distinct& from);
  void MergeFrom(const Distinct& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_partial = 1;
  inline bool has_is_partial() const;
  inline void clear_is_partial();
  static const int kIsPartialFieldNumber = 1;
  inline bool is_partial() const;
  inline void set_is_partial(bool value);

  // @@protoc_insertion_point(class_scope:llql_proto.Distinct)
 private:
  inline void set_has_is_partial();
  inline void clear_has_is_partial();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_partial_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Distinct* default_instance_;
};
// -------------------------------------------------------------------

class Exchange : public ::google::protobuf::Message {
 public:
  Exchange();
  virtual ~Exchange();

  Exchange(const Exchange& from);

  inline Exchange& operator=(const Exchange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Exchange& default_instance();

  void Swap(Exchange* other);

  // implements Message ----------------------------------------------

  Exchange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Exchange& from);
  void MergeFrom(const Exchange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Exchange_ExchangeType ExchangeType;
  static const ExchangeType BROADCAST = Exchange_ExchangeType_BROADCAST;
  static const ExchangeType HASH = Exchange_ExchangeType_HASH;
  static const ExchangeType RANGE = Exchange_ExchangeType_RANGE;
  static inline bool ExchangeType_IsValid(int value) {
    return Exchange_ExchangeType_IsValid(value);
  }
  static const ExchangeType ExchangeType_MIN =
    Exchange_ExchangeType_ExchangeType_MIN;
  static const ExchangeType ExchangeType_MAX =
    Exchange_ExchangeType_ExchangeType_MAX;
  static const int ExchangeType_ARRAYSIZE =
    Exchange_ExchangeType_ExchangeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExchangeType_descriptor() {
    return Exchange_ExchangeType_descriptor();
  }
  static inline const ::std::string& ExchangeType_Name(ExchangeType value) {
    return Exchange_ExchangeType_Name(value);
  }
  static inline bool ExchangeType_Parse(const ::std::string& name,
      ExchangeType* value) {
    return Exchange_ExchangeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .llql_proto.Exchange.ExchangeType x_type = 1;
  inline bool has_x_type() const;
  inline void clear_x_type();
  static const int kXTypeFieldNumber = 1;
  inline ::llql_proto::Exchange_ExchangeType x_type() const;
  inline void set_x_type(::llql_proto::Exchange_ExchangeType value);

  // required int32 x_part = 2;
  inline bool has_x_part() const;
  inline void clear_x_part();
  static const int kXPartFieldNumber = 2;
  inline ::google::protobuf::int32 x_part() const;
  inline void set_x_part(::google::protobuf::int32 value);

  // repeated .llql_proto.Expr x_exprs = 3;
  inline int x_exprs_size() const;
  inline void clear_x_exprs();
  static const int kXExprsFieldNumber = 3;
  inline const ::llql_proto::Expr& x_exprs(int index) const;
  inline ::llql_proto::Expr* mutable_x_exprs(int index);
  inline ::llql_proto::Expr* add_x_exprs();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
      x_exprs() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
      mutable_x_exprs();

  // repeated .llql_proto.SortExpr x_sortexprs = 4;
  inline int x_sortexprs_size() const;
  inline void clear_x_sortexprs();
  static const int kXSortexprsFieldNumber = 4;
  inline const ::llql_proto::SortExpr& x_sortexprs(int index) const;
  inline ::llql_proto::SortExpr* mutable_x_sortexprs(int index);
  inline ::llql_proto::SortExpr* add_x_sortexprs();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >&
      x_sortexprs() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >*
      mutable_x_sortexprs();

  // @@protoc_insertion_point(class_scope:llql_proto.Exchange)
 private:
  inline void set_has_x_type();
  inline void clear_has_x_type();
  inline void set_has_x_part();
  inline void clear_has_x_part();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int x_type_;
  ::google::protobuf::int32 x_part_;
  ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr > x_exprs_;
  ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr > x_sortexprs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Exchange* default_instance_;
};
// -------------------------------------------------------------------

class ExtScan : public ::google::protobuf::Message {
 public:
  ExtScan();
  virtual ~ExtScan();

  ExtScan(const ExtScan& from);

  inline ExtScan& operator=(const ExtScan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtScan& default_instance();

  void Swap(ExtScan* other);

  // implements Message ----------------------------------------------

  ExtScan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtScan& from);
  void MergeFrom(const ExtScan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ExtScan_DSType DSType;
  static const DSType CSV = ExtScan_DSType_CSV;
  static const DSType PG_TEXT = ExtScan_DSType_PG_TEXT;
  static const DSType PARQUET = ExtScan_DSType_PARQUET;
  static inline bool DSType_IsValid(int value) {
    return ExtScan_DSType_IsValid(value);
  }
  static const DSType DSType_MIN =
    ExtScan_DSType_DSType_MIN;
  static const DSType DSType_MAX =
    ExtScan_DSType_DSType_MAX;
  static const int DSType_ARRAYSIZE =
    ExtScan_DSType_DSType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DSType_descriptor() {
    return ExtScan_DSType_descriptor();
  }
  static inline const ::std::string& DSType_Name(DSType value) {
    return ExtScan_DSType_Name(value);
  }
  static inline bool DSType_Parse(const ::std::string& name,
      DSType* value) {
    return ExtScan_DSType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .llql_proto.ExtScan.DSType ds_type = 1;
  inline bool has_ds_type() const;
  inline void clear_ds_type();
  static const int kDsTypeFieldNumber = 1;
  inline ::llql_proto::ExtScan_DSType ds_type() const;
  inline void set_ds_type(::llql_proto::ExtScan_DSType value);

  // repeated string urls = 2;
  inline int urls_size() const;
  inline void clear_urls();
  static const int kUrlsFieldNumber = 2;
  inline const ::std::string& urls(int index) const;
  inline ::std::string* mutable_urls(int index);
  inline void set_urls(int index, const ::std::string& value);
  inline void set_urls(int index, const char* value);
  inline void set_urls(int index, const char* value, size_t size);
  inline ::std::string* add_urls();
  inline void add_urls(const ::std::string& value);
  inline void add_urls(const char* value);
  inline void add_urls(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& urls() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_urls();

  // required .llql_proto.Schema cols = 3;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 3;
  inline const ::llql_proto::Schema& cols() const;
  inline ::llql_proto::Schema* mutable_cols();
  inline ::llql_proto::Schema* release_cols();
  inline void set_allocated_cols(::llql_proto::Schema* cols);

  // @@protoc_insertion_point(class_scope:llql_proto.ExtScan)
 private:
  inline void set_has_ds_type();
  inline void clear_has_ds_type();
  inline void set_has_cols();
  inline void clear_has_cols();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> urls_;
  ::llql_proto::Schema* cols_;
  int ds_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static ExtScan* default_instance_;
};
// -------------------------------------------------------------------

class Filter : public ::google::protobuf::Message {
 public:
  Filter();
  virtual ~Filter();

  Filter(const Filter& from);

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Filter& default_instance();

  void Swap(Filter* other);

  // implements Message ----------------------------------------------

  Filter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Filter& from);
  void MergeFrom(const Filter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .llql_proto.Expr predicate = 1;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  inline const ::llql_proto::Expr& predicate() const;
  inline ::llql_proto::Expr* mutable_predicate();
  inline ::llql_proto::Expr* release_predicate();
  inline void set_allocated_predicate(::llql_proto::Expr* predicate);

  // @@protoc_insertion_point(class_scope:llql_proto.Filter)
 private:
  inline void set_has_predicate();
  inline void clear_has_predicate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::llql_proto::Expr* predicate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Filter* default_instance_;
};
// -------------------------------------------------------------------

class Generator : public ::google::protobuf::Message {
 public:
  Generator();
  virtual ~Generator();

  Generator(const Generator& from);

  inline Generator& operator=(const Generator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Generator& default_instance();

  void Swap(Generator* other);

  // implements Message ----------------------------------------------

  Generator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Generator& from);
  void MergeFrom(const Generator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .llql_proto.Expr expand_array = 1;
  inline int expand_array_size() const;
  inline void clear_expand_array();
  static const int kExpandArrayFieldNumber = 1;
  inline const ::llql_proto::Expr& expand_array(int index) const;
  inline ::llql_proto::Expr* mutable_expand_array(int index);
  inline ::llql_proto::Expr* add_expand_array();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
      expand_array() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
      mutable_expand_array();

  // optional .llql_proto.Expr gen_function = 2;
  inline bool has_gen_function() const;
  inline void clear_gen_function();
  static const int kGenFunctionFieldNumber = 2;
  inline const ::llql_proto::Expr& gen_function() const;
  inline ::llql_proto::Expr* mutable_gen_function();
  inline ::llql_proto::Expr* release_gen_function();
  inline void set_allocated_gen_function(::llql_proto::Expr* gen_function);

  // @@protoc_insertion_point(class_scope:llql_proto.Generator)
 private:
  inline void set_has_gen_function();
  inline void clear_has_gen_function();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr > expand_array_;
  ::llql_proto::Expr* gen_function_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Generator* default_instance_;
};
// -------------------------------------------------------------------

class HashAgg : public ::google::protobuf::Message {
 public:
  HashAgg();
  virtual ~HashAgg();

  HashAgg(const HashAgg& from);

  inline HashAgg& operator=(const HashAgg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashAgg& default_instance();

  void Swap(HashAgg* other);

  // implements Message ----------------------------------------------

  HashAgg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashAgg& from);
  void MergeFrom(const HashAgg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_partial = 1;
  inline bool has_is_partial() const;
  inline void clear_is_partial();
  static const int kIsPartialFieldNumber = 1;
  inline bool is_partial() const;
  inline void set_is_partial(bool value);

  // required bool is_top = 2;
  inline bool has_is_top() const;
  inline void clear_is_top();
  static const int kIsTopFieldNumber = 2;
  inline bool is_top() const;
  inline void set_is_top(bool value);

  // repeated .llql_proto.Expr grp_exprs = 3;
  inline int grp_exprs_size() const;
  inline void clear_grp_exprs();
  static const int kGrpExprsFieldNumber = 3;
  inline const ::llql_proto::Expr& grp_exprs(int index) const;
  inline ::llql_proto::Expr* mutable_grp_exprs(int index);
  inline ::llql_proto::Expr* add_grp_exprs();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
      grp_exprs() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
      mutable_grp_exprs();

  // repeated .llql_proto.Expr proj_exprs = 4;
  inline int proj_exprs_size() const;
  inline void clear_proj_exprs();
  static const int kProjExprsFieldNumber = 4;
  inline const ::llql_proto::Expr& proj_exprs(int index) const;
  inline ::llql_proto::Expr* mutable_proj_exprs(int index);
  inline ::llql_proto::Expr* add_proj_exprs();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
      proj_exprs() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
      mutable_proj_exprs();

  // @@protoc_insertion_point(class_scope:llql_proto.HashAgg)
 private:
  inline void set_has_is_partial();
  inline void clear_has_is_partial();
  inline void set_has_is_top();
  inline void clear_has_is_top();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr > grp_exprs_;
  ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr > proj_exprs_;
  bool is_partial_;
  bool is_top_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static HashAgg* default_instance_;
};
// -------------------------------------------------------------------

class HashJoin : public ::google::protobuf::Message {
 public:
  HashJoin();
  virtual ~HashJoin();

  HashJoin(const HashJoin& from);

  inline HashJoin& operator=(const HashJoin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashJoin& default_instance();

  void Swap(HashJoin* other);

  // implements Message ----------------------------------------------

  HashJoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashJoin& from);
  void MergeFrom(const HashJoin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .llql_proto.Expr left_keys = 1;
  inline int left_keys_size() const;
  inline void clear_left_keys();
  static const int kLeftKeysFieldNumber = 1;
  inline const ::llql_proto::Expr& left_keys(int index) const;
  inline ::llql_proto::Expr* mutable_left_keys(int index);
  inline ::llql_proto::Expr* add_left_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
      left_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
      mutable_left_keys();

  // repeated .llql_proto.Expr right_keys = 2;
  inline int right_keys_size() const;
  inline void clear_right_keys();
  static const int kRightKeysFieldNumber = 2;
  inline const ::llql_proto::Expr& right_keys(int index) const;
  inline ::llql_proto::Expr* mutable_right_keys(int index);
  inline ::llql_proto::Expr* add_right_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
      right_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
      mutable_right_keys();

  // required int32 build_side = 3;
  inline bool has_build_side() const;
  inline void clear_build_side();
  static const int kBuildSideFieldNumber = 3;
  inline ::google::protobuf::int32 build_side() const;
  inline void set_build_side(::google::protobuf::int32 value);

  // required .llql_proto.JoinType join_type = 4;
  inline bool has_join_type() const;
  inline void clear_join_type();
  static const int kJoinTypeFieldNumber = 4;
  inline ::llql_proto::JoinType join_type() const;
  inline void set_join_type(::llql_proto::JoinType value);

  // optional .llql_proto.Expr extra_predicate = 5;
  inline bool has_extra_predicate() const;
  inline void clear_extra_predicate();
  static const int kExtraPredicateFieldNumber = 5;
  inline const ::llql_proto::Expr& extra_predicate() const;
  inline ::llql_proto::Expr* mutable_extra_predicate();
  inline ::llql_proto::Expr* release_extra_predicate();
  inline void set_allocated_extra_predicate(::llql_proto::Expr* extra_predicate);

  // required bool broadcast = 6;
  inline bool has_broadcast() const;
  inline void clear_broadcast();
  static const int kBroadcastFieldNumber = 6;
  inline bool broadcast() const;
  inline void set_broadcast(bool value);

  // @@protoc_insertion_point(class_scope:llql_proto.HashJoin)
 private:
  inline void set_has_build_side();
  inline void clear_has_build_side();
  inline void set_has_join_type();
  inline void clear_has_join_type();
  inline void set_has_extra_predicate();
  inline void clear_has_extra_predicate();
  inline void set_has_broadcast();
  inline void clear_has_broadcast();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr > left_keys_;
  ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr > right_keys_;
  ::google::protobuf::int32 build_side_;
  int join_type_;
  ::llql_proto::Expr* extra_predicate_;
  bool broadcast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static HashJoin* default_instance_;
};
// -------------------------------------------------------------------

class Limit : public ::google::protobuf::Message {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();

  void Swap(Limit* other);

  // implements Message ----------------------------------------------

  Limit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 limit = 1;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 1;
  inline ::google::protobuf::int64 limit() const;
  inline void set_limit(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:llql_proto.Limit)
 private:
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 limit_;
  ::google::protobuf::int64 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Limit* default_instance_;
};
// -------------------------------------------------------------------

class NestedLoopJoin : public ::google::protobuf::Message {
 public:
  NestedLoopJoin();
  virtual ~NestedLoopJoin();

  NestedLoopJoin(const NestedLoopJoin& from);

  inline NestedLoopJoin& operator=(const NestedLoopJoin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NestedLoopJoin& default_instance();

  void Swap(NestedLoopJoin* other);

  // implements Message ----------------------------------------------

  NestedLoopJoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NestedLoopJoin& from);
  void MergeFrom(const NestedLoopJoin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 build_side = 1;
  inline bool has_build_side() const;
  inline void clear_build_side();
  static const int kBuildSideFieldNumber = 1;
  inline ::google::protobuf::int32 build_side() const;
  inline void set_build_side(::google::protobuf::int32 value);

  // required .llql_proto.JoinType join_type = 2;
  inline bool has_join_type() const;
  inline void clear_join_type();
  static const int kJoinTypeFieldNumber = 2;
  inline ::llql_proto::JoinType join_type() const;
  inline void set_join_type(::llql_proto::JoinType value);

  // optional .llql_proto.Expr predicate = 3;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 3;
  inline const ::llql_proto::Expr& predicate() const;
  inline ::llql_proto::Expr* mutable_predicate();
  inline ::llql_proto::Expr* release_predicate();
  inline void set_allocated_predicate(::llql_proto::Expr* predicate);

  // required bool broadcast = 4;
  inline bool has_broadcast() const;
  inline void clear_broadcast();
  static const int kBroadcastFieldNumber = 4;
  inline bool broadcast() const;
  inline void set_broadcast(bool value);

  // @@protoc_insertion_point(class_scope:llql_proto.NestedLoopJoin)
 private:
  inline void set_has_build_side();
  inline void clear_has_build_side();
  inline void set_has_join_type();
  inline void clear_has_join_type();
  inline void set_has_predicate();
  inline void clear_has_predicate();
  inline void set_has_broadcast();
  inline void clear_has_broadcast();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 build_side_;
  int join_type_;
  ::llql_proto::Expr* predicate_;
  bool broadcast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static NestedLoopJoin* default_instance_;
};
// -------------------------------------------------------------------

class Project : public ::google::protobuf::Message {
 public:
  Project();
  virtual ~Project();

  Project(const Project& from);

  inline Project& operator=(const Project& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Project& default_instance();

  void Swap(Project* other);

  // implements Message ----------------------------------------------

  Project* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Project& from);
  void MergeFrom(const Project& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .llql_proto.Expr exprs = 1;
  inline int exprs_size() const;
  inline void clear_exprs();
  static const int kExprsFieldNumber = 1;
  inline const ::llql_proto::Expr& exprs(int index) const;
  inline ::llql_proto::Expr* mutable_exprs(int index);
  inline ::llql_proto::Expr* add_exprs();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
      exprs() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
      mutable_exprs();

  // @@protoc_insertion_point(class_scope:llql_proto.Project)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr > exprs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Project* default_instance_;
};
// -------------------------------------------------------------------

class Sample : public ::google::protobuf::Message {
 public:
  Sample();
  virtual ~Sample();

  Sample(const Sample& from);

  inline Sample& operator=(const Sample& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sample& default_instance();

  void Swap(Sample* other);

  // implements Message ----------------------------------------------

  Sample* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sample& from);
  void MergeFrom(const Sample& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double fraction = 1;
  inline bool has_fraction() const;
  inline void clear_fraction();
  static const int kFractionFieldNumber = 1;
  inline double fraction() const;
  inline void set_fraction(double value);

  // required bool with_replacement = 2;
  inline bool has_with_replacement() const;
  inline void clear_with_replacement();
  static const int kWithReplacementFieldNumber = 2;
  inline bool with_replacement() const;
  inline void set_with_replacement(bool value);

  // required int64 seed = 3;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 3;
  inline ::google::protobuf::int64 seed() const;
  inline void set_seed(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:llql_proto.Sample)
 private:
  inline void set_has_fraction();
  inline void clear_has_fraction();
  inline void set_has_with_replacement();
  inline void clear_has_with_replacement();
  inline void set_has_seed();
  inline void clear_has_seed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double fraction_;
  ::google::protobuf::int64 seed_;
  bool with_replacement_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Sample* default_instance_;
};
// -------------------------------------------------------------------

class SetOp : public ::google::protobuf::Message {
 public:
  SetOp();
  virtual ~SetOp();

  SetOp(const SetOp& from);

  inline SetOp& operator=(const SetOp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetOp& default_instance();

  void Swap(SetOp* other);

  // implements Message ----------------------------------------------

  SetOp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetOp& from);
  void MergeFrom(const SetOp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SetOp_SetOpType SetOpType;
  static const SetOpType UNION = SetOp_SetOpType_UNION;
  static const SetOpType UNION_ALL = SetOp_SetOpType_UNION_ALL;
  static const SetOpType INTERSECT = SetOp_SetOpType_INTERSECT;
  static const SetOpType EXCEPT = SetOp_SetOpType_EXCEPT;
  static inline bool SetOpType_IsValid(int value) {
    return SetOp_SetOpType_IsValid(value);
  }
  static const SetOpType SetOpType_MIN =
    SetOp_SetOpType_SetOpType_MIN;
  static const SetOpType SetOpType_MAX =
    SetOp_SetOpType_SetOpType_MAX;
  static const int SetOpType_ARRAYSIZE =
    SetOp_SetOpType_SetOpType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SetOpType_descriptor() {
    return SetOp_SetOpType_descriptor();
  }
  static inline const ::std::string& SetOpType_Name(SetOpType value) {
    return SetOp_SetOpType_Name(value);
  }
  static inline bool SetOpType_Parse(const ::std::string& name,
      SetOpType* value) {
    return SetOp_SetOpType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .llql_proto.SetOp.SetOpType setop_type = 1;
  inline bool has_setop_type() const;
  inline void clear_setop_type();
  static const int kSetopTypeFieldNumber = 1;
  inline ::llql_proto::SetOp_SetOpType setop_type() const;
  inline void set_setop_type(::llql_proto::SetOp_SetOpType value);

  // @@protoc_insertion_point(class_scope:llql_proto.SetOp)
 private:
  inline void set_has_setop_type();
  inline void clear_has_setop_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int setop_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static SetOp* default_instance_;
};
// -------------------------------------------------------------------

class Sort : public ::google::protobuf::Message {
 public:
  Sort();
  virtual ~Sort();

  Sort(const Sort& from);

  inline Sort& operator=(const Sort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sort& default_instance();

  void Swap(Sort* other);

  // implements Message ----------------------------------------------

  Sort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sort& from);
  void MergeFrom(const Sort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .llql_proto.SortExpr sort_exprs = 1;
  inline int sort_exprs_size() const;
  inline void clear_sort_exprs();
  static const int kSortExprsFieldNumber = 1;
  inline const ::llql_proto::SortExpr& sort_exprs(int index) const;
  inline ::llql_proto::SortExpr* mutable_sort_exprs(int index);
  inline ::llql_proto::SortExpr* add_sort_exprs();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >&
      sort_exprs() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >*
      mutable_sort_exprs();

  // @@protoc_insertion_point(class_scope:llql_proto.Sort)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr > sort_exprs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Sort* default_instance_;
};
// -------------------------------------------------------------------

class SortLimit : public ::google::protobuf::Message {
 public:
  SortLimit();
  virtual ~SortLimit();

  SortLimit(const SortLimit& from);

  inline SortLimit& operator=(const SortLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SortLimit& default_instance();

  void Swap(SortLimit* other);

  // implements Message ----------------------------------------------

  SortLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SortLimit& from);
  void MergeFrom(const SortLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .llql_proto.SortExpr sort_exprs = 1;
  inline int sort_exprs_size() const;
  inline void clear_sort_exprs();
  static const int kSortExprsFieldNumber = 1;
  inline const ::llql_proto::SortExpr& sort_exprs(int index) const;
  inline ::llql_proto::SortExpr* mutable_sort_exprs(int index);
  inline ::llql_proto::SortExpr* add_sort_exprs();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >&
      sort_exprs() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >*
      mutable_sort_exprs();

  // required int64 limit = 2;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 2;
  inline ::google::protobuf::int64 limit() const;
  inline void set_limit(::google::protobuf::int64 value);

  // required int64 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:llql_proto.SortLimit)
 private:
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr > sort_exprs_;
  ::google::protobuf::int64 limit_;
  ::google::protobuf::int64 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static SortLimit* default_instance_;
};
// -------------------------------------------------------------------

class Emit : public ::google::protobuf::Message {
 public:
  Emit();
  virtual ~Emit();

  Emit(const Emit& from);

  inline Emit& operator=(const Emit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emit& default_instance();

  void Swap(Emit* other);

  // implements Message ----------------------------------------------

  Emit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emit& from);
  void MergeFrom(const Emit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 limit = 1;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 1;
  inline ::google::protobuf::int64 limit() const;
  inline void set_limit(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // required int64 sample_rate = 3;
  inline bool has_sample_rate() const;
  inline void clear_sample_rate();
  static const int kSampleRateFieldNumber = 3;
  inline ::google::protobuf::int64 sample_rate() const;
  inline void set_sample_rate(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:llql_proto.Emit)
 private:
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_sample_rate();
  inline void clear_has_sample_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 limit_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 sample_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Emit* default_instance_;
};
// -------------------------------------------------------------------

class Relation : public ::google::protobuf::Message {
 public:
  Relation();
  virtual ~Relation();

  Relation(const Relation& from);

  inline Relation& operator=(const Relation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Relation& default_instance();

  void Swap(Relation* other);

  // implements Message ----------------------------------------------

  Relation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Relation& from);
  void MergeFrom(const Relation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rel_id = 1;
  inline bool has_rel_id() const;
  inline void clear_rel_id();
  static const int kRelIdFieldNumber = 1;
  inline ::google::protobuf::int32 rel_id() const;
  inline void set_rel_id(::google::protobuf::int32 value);

  // optional string rel_name = 2;
  inline bool has_rel_name() const;
  inline void clear_rel_name();
  static const int kRelNameFieldNumber = 2;
  inline const ::std::string& rel_name() const;
  inline void set_rel_name(const ::std::string& value);
  inline void set_rel_name(const char* value);
  inline void set_rel_name(const char* value, size_t size);
  inline ::std::string* mutable_rel_name();
  inline ::std::string* release_rel_name();
  inline void set_allocated_rel_name(::std::string* rel_name);

  // required .llql_proto.Schema schema = 3;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 3;
  inline const ::llql_proto::Schema& schema() const;
  inline ::llql_proto::Schema* mutable_schema();
  inline ::llql_proto::Schema* release_schema();
  inline void set_allocated_schema(::llql_proto::Schema* schema);

  // repeated int32 children = 4;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 4;
  inline ::google::protobuf::int32 children(int index) const;
  inline void set_children(int index, ::google::protobuf::int32 value);
  inline void add_children(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      children() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_children();

  // optional .llql_proto.Distinct distinct = 5;
  inline bool has_distinct() const;
  inline void clear_distinct();
  static const int kDistinctFieldNumber = 5;
  inline const ::llql_proto::Distinct& distinct() const;
  inline ::llql_proto::Distinct* mutable_distinct();
  inline ::llql_proto::Distinct* release_distinct();
  inline void set_allocated_distinct(::llql_proto::Distinct* distinct);

  // optional .llql_proto.Exchange exchange = 6;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 6;
  inline const ::llql_proto::Exchange& exchange() const;
  inline ::llql_proto::Exchange* mutable_exchange();
  inline ::llql_proto::Exchange* release_exchange();
  inline void set_allocated_exchange(::llql_proto::Exchange* exchange);

  // optional .llql_proto.ExtScan extscan = 7;
  inline bool has_extscan() const;
  inline void clear_extscan();
  static const int kExtscanFieldNumber = 7;
  inline const ::llql_proto::ExtScan& extscan() const;
  inline ::llql_proto::ExtScan* mutable_extscan();
  inline ::llql_proto::ExtScan* release_extscan();
  inline void set_allocated_extscan(::llql_proto::ExtScan* extscan);

  // optional .llql_proto.Filter filter = 8;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 8;
  inline const ::llql_proto::Filter& filter() const;
  inline ::llql_proto::Filter* mutable_filter();
  inline ::llql_proto::Filter* release_filter();
  inline void set_allocated_filter(::llql_proto::Filter* filter);

  // optional .llql_proto.Generator generator = 9;
  inline bool has_generator() const;
  inline void clear_generator();
  static const int kGeneratorFieldNumber = 9;
  inline const ::llql_proto::Generator& generator() const;
  inline ::llql_proto::Generator* mutable_generator();
  inline ::llql_proto::Generator* release_generator();
  inline void set_allocated_generator(::llql_proto::Generator* generator);

  // optional .llql_proto.HashAgg hashagg = 10;
  inline bool has_hashagg() const;
  inline void clear_hashagg();
  static const int kHashaggFieldNumber = 10;
  inline const ::llql_proto::HashAgg& hashagg() const;
  inline ::llql_proto::HashAgg* mutable_hashagg();
  inline ::llql_proto::HashAgg* release_hashagg();
  inline void set_allocated_hashagg(::llql_proto::HashAgg* hashagg);

  // optional .llql_proto.HashJoin hashjoin = 11;
  inline bool has_hashjoin() const;
  inline void clear_hashjoin();
  static const int kHashjoinFieldNumber = 11;
  inline const ::llql_proto::HashJoin& hashjoin() const;
  inline ::llql_proto::HashJoin* mutable_hashjoin();
  inline ::llql_proto::HashJoin* release_hashjoin();
  inline void set_allocated_hashjoin(::llql_proto::HashJoin* hashjoin);

  // optional .llql_proto.Limit limit = 12;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 12;
  inline const ::llql_proto::Limit& limit() const;
  inline ::llql_proto::Limit* mutable_limit();
  inline ::llql_proto::Limit* release_limit();
  inline void set_allocated_limit(::llql_proto::Limit* limit);

  // optional .llql_proto.NestedLoopJoin nestedloopjoin = 13;
  inline bool has_nestedloopjoin() const;
  inline void clear_nestedloopjoin();
  static const int kNestedloopjoinFieldNumber = 13;
  inline const ::llql_proto::NestedLoopJoin& nestedloopjoin() const;
  inline ::llql_proto::NestedLoopJoin* mutable_nestedloopjoin();
  inline ::llql_proto::NestedLoopJoin* release_nestedloopjoin();
  inline void set_allocated_nestedloopjoin(::llql_proto::NestedLoopJoin* nestedloopjoin);

  // optional .llql_proto.Project project = 14;
  inline bool has_project() const;
  inline void clear_project();
  static const int kProjectFieldNumber = 14;
  inline const ::llql_proto::Project& project() const;
  inline ::llql_proto::Project* mutable_project();
  inline ::llql_proto::Project* release_project();
  inline void set_allocated_project(::llql_proto::Project* project);

  // optional .llql_proto.Sample sample = 15;
  inline bool has_sample() const;
  inline void clear_sample();
  static const int kSampleFieldNumber = 15;
  inline const ::llql_proto::Sample& sample() const;
  inline ::llql_proto::Sample* mutable_sample();
  inline ::llql_proto::Sample* release_sample();
  inline void set_allocated_sample(::llql_proto::Sample* sample);

  // optional .llql_proto.SetOp setop = 16;
  inline bool has_setop() const;
  inline void clear_setop();
  static const int kSetopFieldNumber = 16;
  inline const ::llql_proto::SetOp& setop() const;
  inline ::llql_proto::SetOp* mutable_setop();
  inline ::llql_proto::SetOp* release_setop();
  inline void set_allocated_setop(::llql_proto::SetOp* setop);

  // optional .llql_proto.Sort sort = 17;
  inline bool has_sort() const;
  inline void clear_sort();
  static const int kSortFieldNumber = 17;
  inline const ::llql_proto::Sort& sort() const;
  inline ::llql_proto::Sort* mutable_sort();
  inline ::llql_proto::Sort* release_sort();
  inline void set_allocated_sort(::llql_proto::Sort* sort);

  // optional .llql_proto.SortLimit sortlimit = 18;
  inline bool has_sortlimit() const;
  inline void clear_sortlimit();
  static const int kSortlimitFieldNumber = 18;
  inline const ::llql_proto::SortLimit& sortlimit() const;
  inline ::llql_proto::SortLimit* mutable_sortlimit();
  inline ::llql_proto::SortLimit* release_sortlimit();
  inline void set_allocated_sortlimit(::llql_proto::SortLimit* sortlimit);

  // optional .llql_proto.Emit emit = 19;
  inline bool has_emit() const;
  inline void clear_emit();
  static const int kEmitFieldNumber = 19;
  inline const ::llql_proto::Emit& emit() const;
  inline ::llql_proto::Emit* mutable_emit();
  inline ::llql_proto::Emit* release_emit();
  inline void set_allocated_emit(::llql_proto::Emit* emit);

  // @@protoc_insertion_point(class_scope:llql_proto.Relation)
 private:
  inline void set_has_rel_id();
  inline void clear_has_rel_id();
  inline void set_has_rel_name();
  inline void clear_has_rel_name();
  inline void set_has_schema();
  inline void clear_has_schema();
  inline void set_has_distinct();
  inline void clear_has_distinct();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_extscan();
  inline void clear_has_extscan();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_generator();
  inline void clear_has_generator();
  inline void set_has_hashagg();
  inline void clear_has_hashagg();
  inline void set_has_hashjoin();
  inline void clear_has_hashjoin();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_nestedloopjoin();
  inline void clear_has_nestedloopjoin();
  inline void set_has_project();
  inline void clear_has_project();
  inline void set_has_sample();
  inline void clear_has_sample();
  inline void set_has_setop();
  inline void clear_has_setop();
  inline void set_has_sort();
  inline void clear_has_sort();
  inline void set_has_sortlimit();
  inline void clear_has_sortlimit();
  inline void set_has_emit();
  inline void clear_has_emit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rel_name_;
  ::llql_proto::Schema* schema_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > children_;
  ::llql_proto::Distinct* distinct_;
  ::llql_proto::Exchange* exchange_;
  ::llql_proto::ExtScan* extscan_;
  ::llql_proto::Filter* filter_;
  ::llql_proto::Generator* generator_;
  ::llql_proto::HashAgg* hashagg_;
  ::llql_proto::HashJoin* hashjoin_;
  ::llql_proto::Limit* limit_;
  ::llql_proto::NestedLoopJoin* nestedloopjoin_;
  ::llql_proto::Project* project_;
  ::llql_proto::Sample* sample_;
  ::llql_proto::SetOp* setop_;
  ::llql_proto::Sort* sort_;
  ::llql_proto::SortLimit* sortlimit_;
  ::llql_proto::Emit* emit_;
  ::google::protobuf::int32 rel_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Relation* default_instance_;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();

  void Swap(Query* other);

  // implements Message ----------------------------------------------

  Query* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 root = 1;
  inline bool has_root() const;
  inline void clear_root();
  static const int kRootFieldNumber = 1;
  inline ::google::protobuf::int32 root() const;
  inline void set_root(::google::protobuf::int32 value);

  // repeated .llql_proto.Relation rels = 2;
  inline int rels_size() const;
  inline void clear_rels();
  static const int kRelsFieldNumber = 2;
  inline const ::llql_proto::Relation& rels(int index) const;
  inline ::llql_proto::Relation* mutable_rels(int index);
  inline ::llql_proto::Relation* add_rels();
  inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Relation >&
      rels() const;
  inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Relation >*
      mutable_rels();

  // @@protoc_insertion_point(class_scope:llql_proto.Query)
 private:
  inline void set_has_root();
  inline void clear_has_root();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::llql_proto::Relation > rels_;
  ::google::protobuf::int32 root_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Query* default_instance_;
};
// ===================================================================


// ===================================================================

// Distinct

// required bool is_partial = 1;
inline bool Distinct::has_is_partial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Distinct::set_has_is_partial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Distinct::clear_has_is_partial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Distinct::clear_is_partial() {
  is_partial_ = false;
  clear_has_is_partial();
}
inline bool Distinct::is_partial() const {
  return is_partial_;
}
inline void Distinct::set_is_partial(bool value) {
  set_has_is_partial();
  is_partial_ = value;
}

// -------------------------------------------------------------------

// Exchange

// required .llql_proto.Exchange.ExchangeType x_type = 1;
inline bool Exchange::has_x_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exchange::set_has_x_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exchange::clear_has_x_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exchange::clear_x_type() {
  x_type_ = 0;
  clear_has_x_type();
}
inline ::llql_proto::Exchange_ExchangeType Exchange::x_type() const {
  return static_cast< ::llql_proto::Exchange_ExchangeType >(x_type_);
}
inline void Exchange::set_x_type(::llql_proto::Exchange_ExchangeType value) {
  assert(::llql_proto::Exchange_ExchangeType_IsValid(value));
  set_has_x_type();
  x_type_ = value;
}

// required int32 x_part = 2;
inline bool Exchange::has_x_part() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Exchange::set_has_x_part() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Exchange::clear_has_x_part() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Exchange::clear_x_part() {
  x_part_ = 0;
  clear_has_x_part();
}
inline ::google::protobuf::int32 Exchange::x_part() const {
  return x_part_;
}
inline void Exchange::set_x_part(::google::protobuf::int32 value) {
  set_has_x_part();
  x_part_ = value;
}

// repeated .llql_proto.Expr x_exprs = 3;
inline int Exchange::x_exprs_size() const {
  return x_exprs_.size();
}
inline void Exchange::clear_x_exprs() {
  x_exprs_.Clear();
}
inline const ::llql_proto::Expr& Exchange::x_exprs(int index) const {
  return x_exprs_.Get(index);
}
inline ::llql_proto::Expr* Exchange::mutable_x_exprs(int index) {
  return x_exprs_.Mutable(index);
}
inline ::llql_proto::Expr* Exchange::add_x_exprs() {
  return x_exprs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
Exchange::x_exprs() const {
  return x_exprs_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
Exchange::mutable_x_exprs() {
  return &x_exprs_;
}

// repeated .llql_proto.SortExpr x_sortexprs = 4;
inline int Exchange::x_sortexprs_size() const {
  return x_sortexprs_.size();
}
inline void Exchange::clear_x_sortexprs() {
  x_sortexprs_.Clear();
}
inline const ::llql_proto::SortExpr& Exchange::x_sortexprs(int index) const {
  return x_sortexprs_.Get(index);
}
inline ::llql_proto::SortExpr* Exchange::mutable_x_sortexprs(int index) {
  return x_sortexprs_.Mutable(index);
}
inline ::llql_proto::SortExpr* Exchange::add_x_sortexprs() {
  return x_sortexprs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >&
Exchange::x_sortexprs() const {
  return x_sortexprs_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >*
Exchange::mutable_x_sortexprs() {
  return &x_sortexprs_;
}

// -------------------------------------------------------------------

// ExtScan

// required .llql_proto.ExtScan.DSType ds_type = 1;
inline bool ExtScan::has_ds_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtScan::set_has_ds_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtScan::clear_has_ds_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtScan::clear_ds_type() {
  ds_type_ = 0;
  clear_has_ds_type();
}
inline ::llql_proto::ExtScan_DSType ExtScan::ds_type() const {
  return static_cast< ::llql_proto::ExtScan_DSType >(ds_type_);
}
inline void ExtScan::set_ds_type(::llql_proto::ExtScan_DSType value) {
  assert(::llql_proto::ExtScan_DSType_IsValid(value));
  set_has_ds_type();
  ds_type_ = value;
}

// repeated string urls = 2;
inline int ExtScan::urls_size() const {
  return urls_.size();
}
inline void ExtScan::clear_urls() {
  urls_.Clear();
}
inline const ::std::string& ExtScan::urls(int index) const {
  return urls_.Get(index);
}
inline ::std::string* ExtScan::mutable_urls(int index) {
  return urls_.Mutable(index);
}
inline void ExtScan::set_urls(int index, const ::std::string& value) {
  urls_.Mutable(index)->assign(value);
}
inline void ExtScan::set_urls(int index, const char* value) {
  urls_.Mutable(index)->assign(value);
}
inline void ExtScan::set_urls(int index, const char* value, size_t size) {
  urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtScan::add_urls() {
  return urls_.Add();
}
inline void ExtScan::add_urls(const ::std::string& value) {
  urls_.Add()->assign(value);
}
inline void ExtScan::add_urls(const char* value) {
  urls_.Add()->assign(value);
}
inline void ExtScan::add_urls(const char* value, size_t size) {
  urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExtScan::urls() const {
  return urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExtScan::mutable_urls() {
  return &urls_;
}

// required .llql_proto.Schema cols = 3;
inline bool ExtScan::has_cols() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtScan::set_has_cols() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtScan::clear_has_cols() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtScan::clear_cols() {
  if (cols_ != NULL) cols_->::llql_proto::Schema::Clear();
  clear_has_cols();
}
inline const ::llql_proto::Schema& ExtScan::cols() const {
  return cols_ != NULL ? *cols_ : *default_instance_->cols_;
}
inline ::llql_proto::Schema* ExtScan::mutable_cols() {
  set_has_cols();
  if (cols_ == NULL) cols_ = new ::llql_proto::Schema;
  return cols_;
}
inline ::llql_proto::Schema* ExtScan::release_cols() {
  clear_has_cols();
  ::llql_proto::Schema* temp = cols_;
  cols_ = NULL;
  return temp;
}
inline void ExtScan::set_allocated_cols(::llql_proto::Schema* cols) {
  delete cols_;
  cols_ = cols;
  if (cols) {
    set_has_cols();
  } else {
    clear_has_cols();
  }
}

// -------------------------------------------------------------------

// Filter

// required .llql_proto.Expr predicate = 1;
inline bool Filter::has_predicate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Filter::set_has_predicate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Filter::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Filter::clear_predicate() {
  if (predicate_ != NULL) predicate_->::llql_proto::Expr::Clear();
  clear_has_predicate();
}
inline const ::llql_proto::Expr& Filter::predicate() const {
  return predicate_ != NULL ? *predicate_ : *default_instance_->predicate_;
}
inline ::llql_proto::Expr* Filter::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == NULL) predicate_ = new ::llql_proto::Expr;
  return predicate_;
}
inline ::llql_proto::Expr* Filter::release_predicate() {
  clear_has_predicate();
  ::llql_proto::Expr* temp = predicate_;
  predicate_ = NULL;
  return temp;
}
inline void Filter::set_allocated_predicate(::llql_proto::Expr* predicate) {
  delete predicate_;
  predicate_ = predicate;
  if (predicate) {
    set_has_predicate();
  } else {
    clear_has_predicate();
  }
}

// -------------------------------------------------------------------

// Generator

// repeated .llql_proto.Expr expand_array = 1;
inline int Generator::expand_array_size() const {
  return expand_array_.size();
}
inline void Generator::clear_expand_array() {
  expand_array_.Clear();
}
inline const ::llql_proto::Expr& Generator::expand_array(int index) const {
  return expand_array_.Get(index);
}
inline ::llql_proto::Expr* Generator::mutable_expand_array(int index) {
  return expand_array_.Mutable(index);
}
inline ::llql_proto::Expr* Generator::add_expand_array() {
  return expand_array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
Generator::expand_array() const {
  return expand_array_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
Generator::mutable_expand_array() {
  return &expand_array_;
}

// optional .llql_proto.Expr gen_function = 2;
inline bool Generator::has_gen_function() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Generator::set_has_gen_function() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Generator::clear_has_gen_function() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Generator::clear_gen_function() {
  if (gen_function_ != NULL) gen_function_->::llql_proto::Expr::Clear();
  clear_has_gen_function();
}
inline const ::llql_proto::Expr& Generator::gen_function() const {
  return gen_function_ != NULL ? *gen_function_ : *default_instance_->gen_function_;
}
inline ::llql_proto::Expr* Generator::mutable_gen_function() {
  set_has_gen_function();
  if (gen_function_ == NULL) gen_function_ = new ::llql_proto::Expr;
  return gen_function_;
}
inline ::llql_proto::Expr* Generator::release_gen_function() {
  clear_has_gen_function();
  ::llql_proto::Expr* temp = gen_function_;
  gen_function_ = NULL;
  return temp;
}
inline void Generator::set_allocated_gen_function(::llql_proto::Expr* gen_function) {
  delete gen_function_;
  gen_function_ = gen_function;
  if (gen_function) {
    set_has_gen_function();
  } else {
    clear_has_gen_function();
  }
}

// -------------------------------------------------------------------

// HashAgg

// required bool is_partial = 1;
inline bool HashAgg::has_is_partial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HashAgg::set_has_is_partial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HashAgg::clear_has_is_partial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HashAgg::clear_is_partial() {
  is_partial_ = false;
  clear_has_is_partial();
}
inline bool HashAgg::is_partial() const {
  return is_partial_;
}
inline void HashAgg::set_is_partial(bool value) {
  set_has_is_partial();
  is_partial_ = value;
}

// required bool is_top = 2;
inline bool HashAgg::has_is_top() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HashAgg::set_has_is_top() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HashAgg::clear_has_is_top() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HashAgg::clear_is_top() {
  is_top_ = false;
  clear_has_is_top();
}
inline bool HashAgg::is_top() const {
  return is_top_;
}
inline void HashAgg::set_is_top(bool value) {
  set_has_is_top();
  is_top_ = value;
}

// repeated .llql_proto.Expr grp_exprs = 3;
inline int HashAgg::grp_exprs_size() const {
  return grp_exprs_.size();
}
inline void HashAgg::clear_grp_exprs() {
  grp_exprs_.Clear();
}
inline const ::llql_proto::Expr& HashAgg::grp_exprs(int index) const {
  return grp_exprs_.Get(index);
}
inline ::llql_proto::Expr* HashAgg::mutable_grp_exprs(int index) {
  return grp_exprs_.Mutable(index);
}
inline ::llql_proto::Expr* HashAgg::add_grp_exprs() {
  return grp_exprs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
HashAgg::grp_exprs() const {
  return grp_exprs_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
HashAgg::mutable_grp_exprs() {
  return &grp_exprs_;
}

// repeated .llql_proto.Expr proj_exprs = 4;
inline int HashAgg::proj_exprs_size() const {
  return proj_exprs_.size();
}
inline void HashAgg::clear_proj_exprs() {
  proj_exprs_.Clear();
}
inline const ::llql_proto::Expr& HashAgg::proj_exprs(int index) const {
  return proj_exprs_.Get(index);
}
inline ::llql_proto::Expr* HashAgg::mutable_proj_exprs(int index) {
  return proj_exprs_.Mutable(index);
}
inline ::llql_proto::Expr* HashAgg::add_proj_exprs() {
  return proj_exprs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
HashAgg::proj_exprs() const {
  return proj_exprs_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
HashAgg::mutable_proj_exprs() {
  return &proj_exprs_;
}

// -------------------------------------------------------------------

// HashJoin

// repeated .llql_proto.Expr left_keys = 1;
inline int HashJoin::left_keys_size() const {
  return left_keys_.size();
}
inline void HashJoin::clear_left_keys() {
  left_keys_.Clear();
}
inline const ::llql_proto::Expr& HashJoin::left_keys(int index) const {
  return left_keys_.Get(index);
}
inline ::llql_proto::Expr* HashJoin::mutable_left_keys(int index) {
  return left_keys_.Mutable(index);
}
inline ::llql_proto::Expr* HashJoin::add_left_keys() {
  return left_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
HashJoin::left_keys() const {
  return left_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
HashJoin::mutable_left_keys() {
  return &left_keys_;
}

// repeated .llql_proto.Expr right_keys = 2;
inline int HashJoin::right_keys_size() const {
  return right_keys_.size();
}
inline void HashJoin::clear_right_keys() {
  right_keys_.Clear();
}
inline const ::llql_proto::Expr& HashJoin::right_keys(int index) const {
  return right_keys_.Get(index);
}
inline ::llql_proto::Expr* HashJoin::mutable_right_keys(int index) {
  return right_keys_.Mutable(index);
}
inline ::llql_proto::Expr* HashJoin::add_right_keys() {
  return right_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
HashJoin::right_keys() const {
  return right_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
HashJoin::mutable_right_keys() {
  return &right_keys_;
}

// required int32 build_side = 3;
inline bool HashJoin::has_build_side() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HashJoin::set_has_build_side() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HashJoin::clear_has_build_side() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HashJoin::clear_build_side() {
  build_side_ = 0;
  clear_has_build_side();
}
inline ::google::protobuf::int32 HashJoin::build_side() const {
  return build_side_;
}
inline void HashJoin::set_build_side(::google::protobuf::int32 value) {
  set_has_build_side();
  build_side_ = value;
}

// required .llql_proto.JoinType join_type = 4;
inline bool HashJoin::has_join_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HashJoin::set_has_join_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HashJoin::clear_has_join_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HashJoin::clear_join_type() {
  join_type_ = 0;
  clear_has_join_type();
}
inline ::llql_proto::JoinType HashJoin::join_type() const {
  return static_cast< ::llql_proto::JoinType >(join_type_);
}
inline void HashJoin::set_join_type(::llql_proto::JoinType value) {
  assert(::llql_proto::JoinType_IsValid(value));
  set_has_join_type();
  join_type_ = value;
}

// optional .llql_proto.Expr extra_predicate = 5;
inline bool HashJoin::has_extra_predicate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HashJoin::set_has_extra_predicate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HashJoin::clear_has_extra_predicate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HashJoin::clear_extra_predicate() {
  if (extra_predicate_ != NULL) extra_predicate_->::llql_proto::Expr::Clear();
  clear_has_extra_predicate();
}
inline const ::llql_proto::Expr& HashJoin::extra_predicate() const {
  return extra_predicate_ != NULL ? *extra_predicate_ : *default_instance_->extra_predicate_;
}
inline ::llql_proto::Expr* HashJoin::mutable_extra_predicate() {
  set_has_extra_predicate();
  if (extra_predicate_ == NULL) extra_predicate_ = new ::llql_proto::Expr;
  return extra_predicate_;
}
inline ::llql_proto::Expr* HashJoin::release_extra_predicate() {
  clear_has_extra_predicate();
  ::llql_proto::Expr* temp = extra_predicate_;
  extra_predicate_ = NULL;
  return temp;
}
inline void HashJoin::set_allocated_extra_predicate(::llql_proto::Expr* extra_predicate) {
  delete extra_predicate_;
  extra_predicate_ = extra_predicate;
  if (extra_predicate) {
    set_has_extra_predicate();
  } else {
    clear_has_extra_predicate();
  }
}

// required bool broadcast = 6;
inline bool HashJoin::has_broadcast() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HashJoin::set_has_broadcast() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HashJoin::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HashJoin::clear_broadcast() {
  broadcast_ = false;
  clear_has_broadcast();
}
inline bool HashJoin::broadcast() const {
  return broadcast_;
}
inline void HashJoin::set_broadcast(bool value) {
  set_has_broadcast();
  broadcast_ = value;
}

// -------------------------------------------------------------------

// Limit

// required int64 limit = 1;
inline bool Limit::has_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Limit::set_has_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Limit::clear_has_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Limit::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
  clear_has_limit();
}
inline ::google::protobuf::int64 Limit::limit() const {
  return limit_;
}
inline void Limit::set_limit(::google::protobuf::int64 value) {
  set_has_limit();
  limit_ = value;
}

// required int64 offset = 2;
inline bool Limit::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Limit::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Limit::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Limit::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 Limit::offset() const {
  return offset_;
}
inline void Limit::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// NestedLoopJoin

// required int32 build_side = 1;
inline bool NestedLoopJoin::has_build_side() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NestedLoopJoin::set_has_build_side() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NestedLoopJoin::clear_has_build_side() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NestedLoopJoin::clear_build_side() {
  build_side_ = 0;
  clear_has_build_side();
}
inline ::google::protobuf::int32 NestedLoopJoin::build_side() const {
  return build_side_;
}
inline void NestedLoopJoin::set_build_side(::google::protobuf::int32 value) {
  set_has_build_side();
  build_side_ = value;
}

// required .llql_proto.JoinType join_type = 2;
inline bool NestedLoopJoin::has_join_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NestedLoopJoin::set_has_join_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NestedLoopJoin::clear_has_join_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NestedLoopJoin::clear_join_type() {
  join_type_ = 0;
  clear_has_join_type();
}
inline ::llql_proto::JoinType NestedLoopJoin::join_type() const {
  return static_cast< ::llql_proto::JoinType >(join_type_);
}
inline void NestedLoopJoin::set_join_type(::llql_proto::JoinType value) {
  assert(::llql_proto::JoinType_IsValid(value));
  set_has_join_type();
  join_type_ = value;
}

// optional .llql_proto.Expr predicate = 3;
inline bool NestedLoopJoin::has_predicate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NestedLoopJoin::set_has_predicate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NestedLoopJoin::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NestedLoopJoin::clear_predicate() {
  if (predicate_ != NULL) predicate_->::llql_proto::Expr::Clear();
  clear_has_predicate();
}
inline const ::llql_proto::Expr& NestedLoopJoin::predicate() const {
  return predicate_ != NULL ? *predicate_ : *default_instance_->predicate_;
}
inline ::llql_proto::Expr* NestedLoopJoin::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == NULL) predicate_ = new ::llql_proto::Expr;
  return predicate_;
}
inline ::llql_proto::Expr* NestedLoopJoin::release_predicate() {
  clear_has_predicate();
  ::llql_proto::Expr* temp = predicate_;
  predicate_ = NULL;
  return temp;
}
inline void NestedLoopJoin::set_allocated_predicate(::llql_proto::Expr* predicate) {
  delete predicate_;
  predicate_ = predicate;
  if (predicate) {
    set_has_predicate();
  } else {
    clear_has_predicate();
  }
}

// required bool broadcast = 4;
inline bool NestedLoopJoin::has_broadcast() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NestedLoopJoin::set_has_broadcast() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NestedLoopJoin::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NestedLoopJoin::clear_broadcast() {
  broadcast_ = false;
  clear_has_broadcast();
}
inline bool NestedLoopJoin::broadcast() const {
  return broadcast_;
}
inline void NestedLoopJoin::set_broadcast(bool value) {
  set_has_broadcast();
  broadcast_ = value;
}

// -------------------------------------------------------------------

// Project

// repeated .llql_proto.Expr exprs = 1;
inline int Project::exprs_size() const {
  return exprs_.size();
}
inline void Project::clear_exprs() {
  exprs_.Clear();
}
inline const ::llql_proto::Expr& Project::exprs(int index) const {
  return exprs_.Get(index);
}
inline ::llql_proto::Expr* Project::mutable_exprs(int index) {
  return exprs_.Mutable(index);
}
inline ::llql_proto::Expr* Project::add_exprs() {
  return exprs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >&
Project::exprs() const {
  return exprs_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Expr >*
Project::mutable_exprs() {
  return &exprs_;
}

// -------------------------------------------------------------------

// Sample

// required double fraction = 1;
inline bool Sample::has_fraction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sample::set_has_fraction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sample::clear_has_fraction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sample::clear_fraction() {
  fraction_ = 0;
  clear_has_fraction();
}
inline double Sample::fraction() const {
  return fraction_;
}
inline void Sample::set_fraction(double value) {
  set_has_fraction();
  fraction_ = value;
}

// required bool with_replacement = 2;
inline bool Sample::has_with_replacement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sample::set_has_with_replacement() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sample::clear_has_with_replacement() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sample::clear_with_replacement() {
  with_replacement_ = false;
  clear_has_with_replacement();
}
inline bool Sample::with_replacement() const {
  return with_replacement_;
}
inline void Sample::set_with_replacement(bool value) {
  set_has_with_replacement();
  with_replacement_ = value;
}

// required int64 seed = 3;
inline bool Sample::has_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sample::set_has_seed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sample::clear_has_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sample::clear_seed() {
  seed_ = GOOGLE_LONGLONG(0);
  clear_has_seed();
}
inline ::google::protobuf::int64 Sample::seed() const {
  return seed_;
}
inline void Sample::set_seed(::google::protobuf::int64 value) {
  set_has_seed();
  seed_ = value;
}

// -------------------------------------------------------------------

// SetOp

// required .llql_proto.SetOp.SetOpType setop_type = 1;
inline bool SetOp::has_setop_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetOp::set_has_setop_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetOp::clear_has_setop_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetOp::clear_setop_type() {
  setop_type_ = 0;
  clear_has_setop_type();
}
inline ::llql_proto::SetOp_SetOpType SetOp::setop_type() const {
  return static_cast< ::llql_proto::SetOp_SetOpType >(setop_type_);
}
inline void SetOp::set_setop_type(::llql_proto::SetOp_SetOpType value) {
  assert(::llql_proto::SetOp_SetOpType_IsValid(value));
  set_has_setop_type();
  setop_type_ = value;
}

// -------------------------------------------------------------------

// Sort

// repeated .llql_proto.SortExpr sort_exprs = 1;
inline int Sort::sort_exprs_size() const {
  return sort_exprs_.size();
}
inline void Sort::clear_sort_exprs() {
  sort_exprs_.Clear();
}
inline const ::llql_proto::SortExpr& Sort::sort_exprs(int index) const {
  return sort_exprs_.Get(index);
}
inline ::llql_proto::SortExpr* Sort::mutable_sort_exprs(int index) {
  return sort_exprs_.Mutable(index);
}
inline ::llql_proto::SortExpr* Sort::add_sort_exprs() {
  return sort_exprs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >&
Sort::sort_exprs() const {
  return sort_exprs_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >*
Sort::mutable_sort_exprs() {
  return &sort_exprs_;
}

// -------------------------------------------------------------------

// SortLimit

// repeated .llql_proto.SortExpr sort_exprs = 1;
inline int SortLimit::sort_exprs_size() const {
  return sort_exprs_.size();
}
inline void SortLimit::clear_sort_exprs() {
  sort_exprs_.Clear();
}
inline const ::llql_proto::SortExpr& SortLimit::sort_exprs(int index) const {
  return sort_exprs_.Get(index);
}
inline ::llql_proto::SortExpr* SortLimit::mutable_sort_exprs(int index) {
  return sort_exprs_.Mutable(index);
}
inline ::llql_proto::SortExpr* SortLimit::add_sort_exprs() {
  return sort_exprs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >&
SortLimit::sort_exprs() const {
  return sort_exprs_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::SortExpr >*
SortLimit::mutable_sort_exprs() {
  return &sort_exprs_;
}

// required int64 limit = 2;
inline bool SortLimit::has_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SortLimit::set_has_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SortLimit::clear_has_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SortLimit::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
  clear_has_limit();
}
inline ::google::protobuf::int64 SortLimit::limit() const {
  return limit_;
}
inline void SortLimit::set_limit(::google::protobuf::int64 value) {
  set_has_limit();
  limit_ = value;
}

// required int64 offset = 3;
inline bool SortLimit::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SortLimit::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SortLimit::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SortLimit::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 SortLimit::offset() const {
  return offset_;
}
inline void SortLimit::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// Emit

// required int64 limit = 1;
inline bool Emit::has_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emit::set_has_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emit::clear_has_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emit::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
  clear_has_limit();
}
inline ::google::protobuf::int64 Emit::limit() const {
  return limit_;
}
inline void Emit::set_limit(::google::protobuf::int64 value) {
  set_has_limit();
  limit_ = value;
}

// required int64 offset = 2;
inline bool Emit::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emit::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emit::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emit::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 Emit::offset() const {
  return offset_;
}
inline void Emit::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// required int64 sample_rate = 3;
inline bool Emit::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emit::set_has_sample_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emit::clear_has_sample_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emit::clear_sample_rate() {
  sample_rate_ = GOOGLE_LONGLONG(0);
  clear_has_sample_rate();
}
inline ::google::protobuf::int64 Emit::sample_rate() const {
  return sample_rate_;
}
inline void Emit::set_sample_rate(::google::protobuf::int64 value) {
  set_has_sample_rate();
  sample_rate_ = value;
}

// -------------------------------------------------------------------

// Relation

// required int32 rel_id = 1;
inline bool Relation::has_rel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Relation::set_has_rel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Relation::clear_has_rel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Relation::clear_rel_id() {
  rel_id_ = 0;
  clear_has_rel_id();
}
inline ::google::protobuf::int32 Relation::rel_id() const {
  return rel_id_;
}
inline void Relation::set_rel_id(::google::protobuf::int32 value) {
  set_has_rel_id();
  rel_id_ = value;
}

// optional string rel_name = 2;
inline bool Relation::has_rel_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Relation::set_has_rel_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Relation::clear_has_rel_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Relation::clear_rel_name() {
  if (rel_name_ != &::google::protobuf::internal::kEmptyString) {
    rel_name_->clear();
  }
  clear_has_rel_name();
}
inline const ::std::string& Relation::rel_name() const {
  return *rel_name_;
}
inline void Relation::set_rel_name(const ::std::string& value) {
  set_has_rel_name();
  if (rel_name_ == &::google::protobuf::internal::kEmptyString) {
    rel_name_ = new ::std::string;
  }
  rel_name_->assign(value);
}
inline void Relation::set_rel_name(const char* value) {
  set_has_rel_name();
  if (rel_name_ == &::google::protobuf::internal::kEmptyString) {
    rel_name_ = new ::std::string;
  }
  rel_name_->assign(value);
}
inline void Relation::set_rel_name(const char* value, size_t size) {
  set_has_rel_name();
  if (rel_name_ == &::google::protobuf::internal::kEmptyString) {
    rel_name_ = new ::std::string;
  }
  rel_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Relation::mutable_rel_name() {
  set_has_rel_name();
  if (rel_name_ == &::google::protobuf::internal::kEmptyString) {
    rel_name_ = new ::std::string;
  }
  return rel_name_;
}
inline ::std::string* Relation::release_rel_name() {
  clear_has_rel_name();
  if (rel_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rel_name_;
    rel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Relation::set_allocated_rel_name(::std::string* rel_name) {
  if (rel_name_ != &::google::protobuf::internal::kEmptyString) {
    delete rel_name_;
  }
  if (rel_name) {
    set_has_rel_name();
    rel_name_ = rel_name;
  } else {
    clear_has_rel_name();
    rel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .llql_proto.Schema schema = 3;
inline bool Relation::has_schema() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Relation::set_has_schema() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Relation::clear_has_schema() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Relation::clear_schema() {
  if (schema_ != NULL) schema_->::llql_proto::Schema::Clear();
  clear_has_schema();
}
inline const ::llql_proto::Schema& Relation::schema() const {
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
}
inline ::llql_proto::Schema* Relation::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::llql_proto::Schema;
  return schema_;
}
inline ::llql_proto::Schema* Relation::release_schema() {
  clear_has_schema();
  ::llql_proto::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void Relation::set_allocated_schema(::llql_proto::Schema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
}

// repeated int32 children = 4;
inline int Relation::children_size() const {
  return children_.size();
}
inline void Relation::clear_children() {
  children_.Clear();
}
inline ::google::protobuf::int32 Relation::children(int index) const {
  return children_.Get(index);
}
inline void Relation::set_children(int index, ::google::protobuf::int32 value) {
  children_.Set(index, value);
}
inline void Relation::add_children(::google::protobuf::int32 value) {
  children_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Relation::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Relation::mutable_children() {
  return &children_;
}

// optional .llql_proto.Distinct distinct = 5;
inline bool Relation::has_distinct() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Relation::set_has_distinct() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Relation::clear_has_distinct() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Relation::clear_distinct() {
  if (distinct_ != NULL) distinct_->::llql_proto::Distinct::Clear();
  clear_has_distinct();
}
inline const ::llql_proto::Distinct& Relation::distinct() const {
  return distinct_ != NULL ? *distinct_ : *default_instance_->distinct_;
}
inline ::llql_proto::Distinct* Relation::mutable_distinct() {
  set_has_distinct();
  if (distinct_ == NULL) distinct_ = new ::llql_proto::Distinct;
  return distinct_;
}
inline ::llql_proto::Distinct* Relation::release_distinct() {
  clear_has_distinct();
  ::llql_proto::Distinct* temp = distinct_;
  distinct_ = NULL;
  return temp;
}
inline void Relation::set_allocated_distinct(::llql_proto::Distinct* distinct) {
  delete distinct_;
  distinct_ = distinct;
  if (distinct) {
    set_has_distinct();
  } else {
    clear_has_distinct();
  }
}

// optional .llql_proto.Exchange exchange = 6;
inline bool Relation::has_exchange() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Relation::set_has_exchange() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Relation::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Relation::clear_exchange() {
  if (exchange_ != NULL) exchange_->::llql_proto::Exchange::Clear();
  clear_has_exchange();
}
inline const ::llql_proto::Exchange& Relation::exchange() const {
  return exchange_ != NULL ? *exchange_ : *default_instance_->exchange_;
}
inline ::llql_proto::Exchange* Relation::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == NULL) exchange_ = new ::llql_proto::Exchange;
  return exchange_;
}
inline ::llql_proto::Exchange* Relation::release_exchange() {
  clear_has_exchange();
  ::llql_proto::Exchange* temp = exchange_;
  exchange_ = NULL;
  return temp;
}
inline void Relation::set_allocated_exchange(::llql_proto::Exchange* exchange) {
  delete exchange_;
  exchange_ = exchange;
  if (exchange) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
}

// optional .llql_proto.ExtScan extscan = 7;
inline bool Relation::has_extscan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Relation::set_has_extscan() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Relation::clear_has_extscan() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Relation::clear_extscan() {
  if (extscan_ != NULL) extscan_->::llql_proto::ExtScan::Clear();
  clear_has_extscan();
}
inline const ::llql_proto::ExtScan& Relation::extscan() const {
  return extscan_ != NULL ? *extscan_ : *default_instance_->extscan_;
}
inline ::llql_proto::ExtScan* Relation::mutable_extscan() {
  set_has_extscan();
  if (extscan_ == NULL) extscan_ = new ::llql_proto::ExtScan;
  return extscan_;
}
inline ::llql_proto::ExtScan* Relation::release_extscan() {
  clear_has_extscan();
  ::llql_proto::ExtScan* temp = extscan_;
  extscan_ = NULL;
  return temp;
}
inline void Relation::set_allocated_extscan(::llql_proto::ExtScan* extscan) {
  delete extscan_;
  extscan_ = extscan;
  if (extscan) {
    set_has_extscan();
  } else {
    clear_has_extscan();
  }
}

// optional .llql_proto.Filter filter = 8;
inline bool Relation::has_filter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Relation::set_has_filter() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Relation::clear_has_filter() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Relation::clear_filter() {
  if (filter_ != NULL) filter_->::llql_proto::Filter::Clear();
  clear_has_filter();
}
inline const ::llql_proto::Filter& Relation::filter() const {
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::llql_proto::Filter* Relation::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::llql_proto::Filter;
  return filter_;
}
inline ::llql_proto::Filter* Relation::release_filter() {
  clear_has_filter();
  ::llql_proto::Filter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void Relation::set_allocated_filter(::llql_proto::Filter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
}

// optional .llql_proto.Generator generator = 9;
inline bool Relation::has_generator() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Relation::set_has_generator() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Relation::clear_has_generator() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Relation::clear_generator() {
  if (generator_ != NULL) generator_->::llql_proto::Generator::Clear();
  clear_has_generator();
}
inline const ::llql_proto::Generator& Relation::generator() const {
  return generator_ != NULL ? *generator_ : *default_instance_->generator_;
}
inline ::llql_proto::Generator* Relation::mutable_generator() {
  set_has_generator();
  if (generator_ == NULL) generator_ = new ::llql_proto::Generator;
  return generator_;
}
inline ::llql_proto::Generator* Relation::release_generator() {
  clear_has_generator();
  ::llql_proto::Generator* temp = generator_;
  generator_ = NULL;
  return temp;
}
inline void Relation::set_allocated_generator(::llql_proto::Generator* generator) {
  delete generator_;
  generator_ = generator;
  if (generator) {
    set_has_generator();
  } else {
    clear_has_generator();
  }
}

// optional .llql_proto.HashAgg hashagg = 10;
inline bool Relation::has_hashagg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Relation::set_has_hashagg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Relation::clear_has_hashagg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Relation::clear_hashagg() {
  if (hashagg_ != NULL) hashagg_->::llql_proto::HashAgg::Clear();
  clear_has_hashagg();
}
inline const ::llql_proto::HashAgg& Relation::hashagg() const {
  return hashagg_ != NULL ? *hashagg_ : *default_instance_->hashagg_;
}
inline ::llql_proto::HashAgg* Relation::mutable_hashagg() {
  set_has_hashagg();
  if (hashagg_ == NULL) hashagg_ = new ::llql_proto::HashAgg;
  return hashagg_;
}
inline ::llql_proto::HashAgg* Relation::release_hashagg() {
  clear_has_hashagg();
  ::llql_proto::HashAgg* temp = hashagg_;
  hashagg_ = NULL;
  return temp;
}
inline void Relation::set_allocated_hashagg(::llql_proto::HashAgg* hashagg) {
  delete hashagg_;
  hashagg_ = hashagg;
  if (hashagg) {
    set_has_hashagg();
  } else {
    clear_has_hashagg();
  }
}

// optional .llql_proto.HashJoin hashjoin = 11;
inline bool Relation::has_hashjoin() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Relation::set_has_hashjoin() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Relation::clear_has_hashjoin() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Relation::clear_hashjoin() {
  if (hashjoin_ != NULL) hashjoin_->::llql_proto::HashJoin::Clear();
  clear_has_hashjoin();
}
inline const ::llql_proto::HashJoin& Relation::hashjoin() const {
  return hashjoin_ != NULL ? *hashjoin_ : *default_instance_->hashjoin_;
}
inline ::llql_proto::HashJoin* Relation::mutable_hashjoin() {
  set_has_hashjoin();
  if (hashjoin_ == NULL) hashjoin_ = new ::llql_proto::HashJoin;
  return hashjoin_;
}
inline ::llql_proto::HashJoin* Relation::release_hashjoin() {
  clear_has_hashjoin();
  ::llql_proto::HashJoin* temp = hashjoin_;
  hashjoin_ = NULL;
  return temp;
}
inline void Relation::set_allocated_hashjoin(::llql_proto::HashJoin* hashjoin) {
  delete hashjoin_;
  hashjoin_ = hashjoin;
  if (hashjoin) {
    set_has_hashjoin();
  } else {
    clear_has_hashjoin();
  }
}

// optional .llql_proto.Limit limit = 12;
inline bool Relation::has_limit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Relation::set_has_limit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Relation::clear_has_limit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Relation::clear_limit() {
  if (limit_ != NULL) limit_->::llql_proto::Limit::Clear();
  clear_has_limit();
}
inline const ::llql_proto::Limit& Relation::limit() const {
  return limit_ != NULL ? *limit_ : *default_instance_->limit_;
}
inline ::llql_proto::Limit* Relation::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) limit_ = new ::llql_proto::Limit;
  return limit_;
}
inline ::llql_proto::Limit* Relation::release_limit() {
  clear_has_limit();
  ::llql_proto::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void Relation::set_allocated_limit(::llql_proto::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    set_has_limit();
  } else {
    clear_has_limit();
  }
}

// optional .llql_proto.NestedLoopJoin nestedloopjoin = 13;
inline bool Relation::has_nestedloopjoin() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Relation::set_has_nestedloopjoin() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Relation::clear_has_nestedloopjoin() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Relation::clear_nestedloopjoin() {
  if (nestedloopjoin_ != NULL) nestedloopjoin_->::llql_proto::NestedLoopJoin::Clear();
  clear_has_nestedloopjoin();
}
inline const ::llql_proto::NestedLoopJoin& Relation::nestedloopjoin() const {
  return nestedloopjoin_ != NULL ? *nestedloopjoin_ : *default_instance_->nestedloopjoin_;
}
inline ::llql_proto::NestedLoopJoin* Relation::mutable_nestedloopjoin() {
  set_has_nestedloopjoin();
  if (nestedloopjoin_ == NULL) nestedloopjoin_ = new ::llql_proto::NestedLoopJoin;
  return nestedloopjoin_;
}
inline ::llql_proto::NestedLoopJoin* Relation::release_nestedloopjoin() {
  clear_has_nestedloopjoin();
  ::llql_proto::NestedLoopJoin* temp = nestedloopjoin_;
  nestedloopjoin_ = NULL;
  return temp;
}
inline void Relation::set_allocated_nestedloopjoin(::llql_proto::NestedLoopJoin* nestedloopjoin) {
  delete nestedloopjoin_;
  nestedloopjoin_ = nestedloopjoin;
  if (nestedloopjoin) {
    set_has_nestedloopjoin();
  } else {
    clear_has_nestedloopjoin();
  }
}

// optional .llql_proto.Project project = 14;
inline bool Relation::has_project() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Relation::set_has_project() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Relation::clear_has_project() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Relation::clear_project() {
  if (project_ != NULL) project_->::llql_proto::Project::Clear();
  clear_has_project();
}
inline const ::llql_proto::Project& Relation::project() const {
  return project_ != NULL ? *project_ : *default_instance_->project_;
}
inline ::llql_proto::Project* Relation::mutable_project() {
  set_has_project();
  if (project_ == NULL) project_ = new ::llql_proto::Project;
  return project_;
}
inline ::llql_proto::Project* Relation::release_project() {
  clear_has_project();
  ::llql_proto::Project* temp = project_;
  project_ = NULL;
  return temp;
}
inline void Relation::set_allocated_project(::llql_proto::Project* project) {
  delete project_;
  project_ = project;
  if (project) {
    set_has_project();
  } else {
    clear_has_project();
  }
}

// optional .llql_proto.Sample sample = 15;
inline bool Relation::has_sample() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Relation::set_has_sample() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Relation::clear_has_sample() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Relation::clear_sample() {
  if (sample_ != NULL) sample_->::llql_proto::Sample::Clear();
  clear_has_sample();
}
inline const ::llql_proto::Sample& Relation::sample() const {
  return sample_ != NULL ? *sample_ : *default_instance_->sample_;
}
inline ::llql_proto::Sample* Relation::mutable_sample() {
  set_has_sample();
  if (sample_ == NULL) sample_ = new ::llql_proto::Sample;
  return sample_;
}
inline ::llql_proto::Sample* Relation::release_sample() {
  clear_has_sample();
  ::llql_proto::Sample* temp = sample_;
  sample_ = NULL;
  return temp;
}
inline void Relation::set_allocated_sample(::llql_proto::Sample* sample) {
  delete sample_;
  sample_ = sample;
  if (sample) {
    set_has_sample();
  } else {
    clear_has_sample();
  }
}

// optional .llql_proto.SetOp setop = 16;
inline bool Relation::has_setop() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Relation::set_has_setop() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Relation::clear_has_setop() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Relation::clear_setop() {
  if (setop_ != NULL) setop_->::llql_proto::SetOp::Clear();
  clear_has_setop();
}
inline const ::llql_proto::SetOp& Relation::setop() const {
  return setop_ != NULL ? *setop_ : *default_instance_->setop_;
}
inline ::llql_proto::SetOp* Relation::mutable_setop() {
  set_has_setop();
  if (setop_ == NULL) setop_ = new ::llql_proto::SetOp;
  return setop_;
}
inline ::llql_proto::SetOp* Relation::release_setop() {
  clear_has_setop();
  ::llql_proto::SetOp* temp = setop_;
  setop_ = NULL;
  return temp;
}
inline void Relation::set_allocated_setop(::llql_proto::SetOp* setop) {
  delete setop_;
  setop_ = setop;
  if (setop) {
    set_has_setop();
  } else {
    clear_has_setop();
  }
}

// optional .llql_proto.Sort sort = 17;
inline bool Relation::has_sort() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Relation::set_has_sort() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Relation::clear_has_sort() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Relation::clear_sort() {
  if (sort_ != NULL) sort_->::llql_proto::Sort::Clear();
  clear_has_sort();
}
inline const ::llql_proto::Sort& Relation::sort() const {
  return sort_ != NULL ? *sort_ : *default_instance_->sort_;
}
inline ::llql_proto::Sort* Relation::mutable_sort() {
  set_has_sort();
  if (sort_ == NULL) sort_ = new ::llql_proto::Sort;
  return sort_;
}
inline ::llql_proto::Sort* Relation::release_sort() {
  clear_has_sort();
  ::llql_proto::Sort* temp = sort_;
  sort_ = NULL;
  return temp;
}
inline void Relation::set_allocated_sort(::llql_proto::Sort* sort) {
  delete sort_;
  sort_ = sort;
  if (sort) {
    set_has_sort();
  } else {
    clear_has_sort();
  }
}

// optional .llql_proto.SortLimit sortlimit = 18;
inline bool Relation::has_sortlimit() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Relation::set_has_sortlimit() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Relation::clear_has_sortlimit() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Relation::clear_sortlimit() {
  if (sortlimit_ != NULL) sortlimit_->::llql_proto::SortLimit::Clear();
  clear_has_sortlimit();
}
inline const ::llql_proto::SortLimit& Relation::sortlimit() const {
  return sortlimit_ != NULL ? *sortlimit_ : *default_instance_->sortlimit_;
}
inline ::llql_proto::SortLimit* Relation::mutable_sortlimit() {
  set_has_sortlimit();
  if (sortlimit_ == NULL) sortlimit_ = new ::llql_proto::SortLimit;
  return sortlimit_;
}
inline ::llql_proto::SortLimit* Relation::release_sortlimit() {
  clear_has_sortlimit();
  ::llql_proto::SortLimit* temp = sortlimit_;
  sortlimit_ = NULL;
  return temp;
}
inline void Relation::set_allocated_sortlimit(::llql_proto::SortLimit* sortlimit) {
  delete sortlimit_;
  sortlimit_ = sortlimit;
  if (sortlimit) {
    set_has_sortlimit();
  } else {
    clear_has_sortlimit();
  }
}

// optional .llql_proto.Emit emit = 19;
inline bool Relation::has_emit() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Relation::set_has_emit() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Relation::clear_has_emit() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Relation::clear_emit() {
  if (emit_ != NULL) emit_->::llql_proto::Emit::Clear();
  clear_has_emit();
}
inline const ::llql_proto::Emit& Relation::emit() const {
  return emit_ != NULL ? *emit_ : *default_instance_->emit_;
}
inline ::llql_proto::Emit* Relation::mutable_emit() {
  set_has_emit();
  if (emit_ == NULL) emit_ = new ::llql_proto::Emit;
  return emit_;
}
inline ::llql_proto::Emit* Relation::release_emit() {
  clear_has_emit();
  ::llql_proto::Emit* temp = emit_;
  emit_ = NULL;
  return temp;
}
inline void Relation::set_allocated_emit(::llql_proto::Emit* emit) {
  delete emit_;
  emit_ = emit;
  if (emit) {
    set_has_emit();
  } else {
    clear_has_emit();
  }
}

// -------------------------------------------------------------------

// Query

// required int32 root = 1;
inline bool Query::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Query::set_has_root() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Query::clear_has_root() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Query::clear_root() {
  root_ = 0;
  clear_has_root();
}
inline ::google::protobuf::int32 Query::root() const {
  return root_;
}
inline void Query::set_root(::google::protobuf::int32 value) {
  set_has_root();
  root_ = value;
}

// repeated .llql_proto.Relation rels = 2;
inline int Query::rels_size() const {
  return rels_.size();
}
inline void Query::clear_rels() {
  rels_.Clear();
}
inline const ::llql_proto::Relation& Query::rels(int index) const {
  return rels_.Get(index);
}
inline ::llql_proto::Relation* Query::mutable_rels(int index) {
  return rels_.Mutable(index);
}
inline ::llql_proto::Relation* Query::add_rels() {
  return rels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llql_proto::Relation >&
Query::rels() const {
  return rels_;
}
inline ::google::protobuf::RepeatedPtrField< ::llql_proto::Relation >*
Query::mutable_rels() {
  return &rels_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace llql_proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llql_proto::Exchange_ExchangeType>() {
  return ::llql_proto::Exchange_ExchangeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llql_proto::ExtScan_DSType>() {
  return ::llql_proto::ExtScan_DSType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llql_proto::SetOp_SetOpType>() {
  return ::llql_proto::SetOp_SetOpType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::llql_proto::JoinType>() {
  return ::llql_proto::JoinType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_query_2eproto__INCLUDED
